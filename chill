-- Tap Simulator Optimized v2.0.0
-- Prevent multiple executions
if getgenv().TapSimLoaded then
    local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
    local TempLibrary = loadstring(game:HttpGet(repo .. "Library.lua"))()
    TempLibrary:Notify("Tap Simulator script is already loaded! Please unload it first.", 10)
    return
end
getgenv().TapSimLoaded = true

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local MarketplaceService = game:GetService("MarketplaceService")
local Workspace = game:GetService("Workspace")

local p = Players.LocalPlayer
local rs = ReplicatedStorage

-- Core Framework
local Framework = {
    Modules = {},
    Config = {
        updateRate = 0.5,
        cacheLifetime = 2,
        notificationCooldown = 10,
        maxRemoteBatch = 10,
        remoteFlushInterval = 0.1,
        portalUnlockDelay = 0.5,
        machineSearchDelay = 0.3
    },
    State = {
    autoTap = false,
    autoRebirth = false,
    autoHatch = false,
    autoCraftGolden = false,
    autoCraftRainbow = false,
    autoClaimRainbow = false,
    autoBuyUpgrades = false,
    autoUnlockPortals = false,
    craftingLock = false,
    selectedEgg = "Basic",
    hatchAmount = 1,
    selectedRebirthButton = "Max Unlocked",
    rebirthDelay = 0,
    selectedUpgrades = {},
    upgradeCheckDelay = 2,
    selectedDeleteEgg = "Basic",
    allDeleteSelections = {},
    goldenCraftAmount = 6,
    rainbowCraftAmount = 5,
    selectedGoldenPets = {},
    selectedRainbowPets = {},
    autoSmartSelectGolden = false,
    autoSmartSelectRainbow = false,
    excludedGoldenRarities = {},
    excludedRainbowRarities = {},
    savedPosition = nil,
    savedGoldenMachinePosition = nil,
    savedRainbowMachinePosition = nil,
    savedGoldenIslandMultiplier = 0,
    savedRainbowIslandMultiplier = 0,
    goldenPetSortMethod = "Multiplier (Low to High)",
    rainbowPetSortMethod = "Multiplier (Low to High)",
    enchantPetSortMethod = "Multiplier (Low to High)",
    autoEnchant = false,
    selectedEnchantPet = nil,
    selectedEnchantTypes = {},
    savedEnchantMachinePosition = nil,
    savedEnchantIslandMultiplier = 0,
    excludedEnchantRarities = {},
    excludeEquippedEnchant = false,
    enchantSpinDelay = 5,
    maxPingThreshold = 300,
    adaptiveDelayEnabled = true,
    lastEnchantResult = nil,
    enchantFailStreak = 0,
    showIndividualPetsEnchant = false,
    autoFarmCrystals = false,
    minCrystalsThreshold = 10,
    crystalFarmEgg = nil,
    crystalFarmAmount = 3,
    isCurrentlyFarmingCrystals = false,
    notificationFilters = {
        showCraft = true,
        showRebirth = true,
        showHatch = true,
        showUpgrade = true,
        showPortal = true,
        showGeneral = true
    },
},
    Data = {
        eggData = {},
        eggList = {},
        rebirthData = {},
        rebirthList = {},
        portalsData = {},
        portalsList = {},
        eggPetsData = {},
        petStats = {},
        petRarities = {},
        petTiers = {},
        gemShopUpgrades = {},
        upgradeCategories = {
            ["Double Jumps"] = {
                path = "Tabs.Upgrades2.Menu.Categories.Jumps.Inner.List",
                remote = "UpgradeDoubleJump",
                param = "Main"
            },
            ["Rebirth Buttons"] = {
                path = "Tabs.Upgrades2.Menu.Categories.RebirthButtons.Inner.List",
                remote = "UpgradeGemShop",
                param = "RebirthButtons"
            }
        },
        primaryCurrency = "Clicks",
        replicationData = nil
    },
    Stats = {
        eggStats = {
            totalHatched = 0,
            totalClicksSpent = 0,
            startTime = 0,
            isTracking = false,
            lastUpdateTime = 0
        }
    },
    Connections = {},
    UI = {
        Library = nil,
        Window = nil,
        Tabs = {},
        Options = nil,
        Toggles = nil,
        Labels = {}
    }
}

-- Add this after the Framework initialization, before modules
local PingMonitor = {
    currentPing = 0,
    updateRate = 2
}

function PingMonitor:GetPing()
    local success, ping = pcall(function()
        return p:GetNetworkPing() * 1000 -- Convert to milliseconds
    end)
    return success and ping or 0
end

function PingMonitor:Start()
    task.spawn(function()
        while getgenv().TapSimLoaded do
            self.currentPing = self:GetPing()
            task.wait(self.updateRate)
        end
    end)
end

function PingMonitor:GetAdaptiveDelay(baseDelay)
    if not Framework.State.adaptiveDelayEnabled then
        return baseDelay
    end
    
    local ping = self.currentPing
    
    -- Scale delay based on ping
    if ping < 100 then
        return baseDelay  -- Normal speed
    elseif ping < 150 then
        return baseDelay * 1.3  -- 30% slower
    elseif ping < 200 then
        return baseDelay * 1.6  -- 60% slower
    elseif ping < 250 then
        return baseDelay * 2.0  -- 2x slower
    else
        return baseDelay * 3.0  -- 3x slower for high ping
    end
end

PingMonitor:Start()
Framework.PingMonitor = PingMonitor

function Framework:RegisterModule(name, module)
    self.Modules[name] = module
    if module.Init then 
        module:Init(self) 
    end
    return module
end

function Framework:GetModule(name)
    return self.Modules[name]
end

function Framework:AddConnection(name, connection)
    if self.Connections[name] then
        self.Connections[name]:Disconnect()
    end
    self.Connections[name] = connection
end

function Framework:RemoveConnection(name)
    if self.Connections[name] then
        self.Connections[name]:Disconnect()
        self.Connections[name] = nil
    end
end

function Framework:Cleanup()
    print("üßπ Starting cleanup...")
    
    -- Disconnect all connections
    for _, conn in pairs(self.Connections) do
        if conn and conn.Disconnect then
            pcall(function() conn:Disconnect() end)
        end
    end
    self.Connections = {}
    
    -- Cancel all tracked tasks
    for name, taskThread in pairs(self.Tasks or {}) do
        pcall(function() task.cancel(taskThread) end)
    end
    self.Tasks = {}
    
    -- Stop UI updates
    if self:GetModule("UIUpdate") then
        self:GetModule("UIUpdate"):Stop()
    end
    
    -- Stop anti-AFK
    if self:GetModule("AntiAFK") then
        self:GetModule("AntiAFK"):Stop()
    end
    
    -- Clear all caches
    if self:GetModule("Cache") then
        self:GetModule("Cache"):Clear()
    end
    
    print("‚úì Cleanup complete")
end

-- Cache Module
local CacheModule = {
    cache = {},
    ttl = {},
    numberFormatCache = {}
}

function CacheModule:Init(fw)
    self.framework = fw
    
    -- Start cache cleanup task
    local cleanupTask = task.spawn(function()
        while getgenv().TapSimLoaded do
            task.wait(60) -- Clean every minute
            local now = tick()
            local cleaned = 0
            
            for key, expiry in pairs(self.ttl) do
                if expiry < now then
                    self.cache[key] = nil
                    self.ttl[key] = nil
                    cleaned = cleaned + 1
                end
            end
            
            if cleaned > 0 then
                print("üßπ Cache cleanup: removed " .. cleaned .. " expired entries")
            end
        end
    end)
    
    fw:AddTask("CacheCleanup", cleanupTask)
end

function CacheModule:Get(key, fetchFunc, lifetime)
    local now = tick()
    
    if self.cache[key] and self.ttl[key] and self.ttl[key] > now then
        return self.cache[key]
    end
    
    local success, data = pcall(fetchFunc)
    if success then
        self.cache[key] = data
        self.ttl[key] = now + (lifetime or Framework.Config.cacheLifetime)
        return data
    end
    
    return self.cache[key]
end

function CacheModule:Invalidate(key)
    self.cache[key] = nil
    self.ttl[key] = nil
end

function CacheModule:Clear()
    self.cache = {}
    self.ttl = {}
end

setmetatable(CacheModule.numberFormatCache, {__mode = "kv"})

-- Task Tracking System
Framework.Tasks = {}

function Framework:AddTask(name, taskThread)
    if self.Tasks[name] then
        task.cancel(self.Tasks[name])
    end
    self.Tasks[name] = taskThread
end

function Framework:RemoveTask(name)
    if self.Tasks[name] then
        task.cancel(self.Tasks[name])
        self.Tasks[name] = nil
    end
end

Framework:RegisterModule("Cache", CacheModule)

Framework:RegisterModule("Cache", CacheModule)

-- Format Module
local FormatModule = {}

function FormatModule:FormatNumber(num)
    if CacheModule.numberFormatCache[num] then
        return CacheModule.numberFormatCache[num]
    end
    
    local formatted
    if num >= 1e42 then
        formatted = string.format("%.1fTd", num / 1e42):gsub("%.0Td", "Td")
    elseif num >= 1e39 then
        formatted = string.format("%.1fDd", num / 1e39):gsub("%.0Dd", "Dd")
    elseif num >= 1e36 then
        formatted = string.format("%.1fUd", num / 1e36):gsub("%.0Ud", "Ud")
    elseif num >= 1e33 then
        formatted = string.format("%.1fDc", num / 1e33):gsub("%.0Dc", "Dc")
    elseif num >= 1e30 then
        formatted = string.format("%.1fN", num / 1e30):gsub("%.0N", "N")
    elseif num >= 1e27 then
        formatted = string.format("%.1fO", num / 1e27):gsub("%.0O", "O")
    elseif num >= 1e24 then
        formatted = string.format("%.1fSp", num / 1e24):gsub("%.0Sp", "Sp")
    elseif num >= 1e21 then
        formatted = string.format("%.1fSx", num / 1e21):gsub("%.0Sx", "Sx")
    elseif num >= 1e18 then
        formatted = string.format("%.1fQn", num / 1e18):gsub("%.0Qn", "Qn")
    elseif num >= 1e15 then
        formatted = string.format("%.1fQd", num / 1e15):gsub("%.0Qd", "Qd")
    elseif num >= 1e12 then
        formatted = string.format("%.1fT", num / 1e12):gsub("%.0T", "T")
    elseif num >= 1e9 then
        formatted = string.format("%.1fB", num / 1e9):gsub("%.0B", "B")
    elseif num >= 1e6 then
        formatted = string.format("%.1fM", num / 1e6):gsub("%.0M", "M")
    elseif num >= 1e3 then
        formatted = string.format("%.1fK", num / 1e3):gsub("%.0K", "K")
    else
        formatted = tostring(num)
    end
    
    CacheModule.numberFormatCache[num] = formatted
    return formatted
end

Framework:RegisterModule("Format", FormatModule)

-- Debounce Utility
local DebounceModule = {}

function DebounceModule:Create(func, delay)
    local timer = nil
    return function(...)
        local args = {...}
        if timer then
            task.cancel(timer)
        end
        timer = task.delay(delay, function()
            func(table.unpack(args))
        end)
    end
end

Framework:RegisterModule("Debounce", DebounceModule)

-- Remote Queue Module
local RemoteQueueModule = {
    queue = {},
    isProcessing = false
}

function RemoteQueueModule:Init(fw)
    self.framework = fw
    
    task.spawn(function()
        while getgenv().TapSimLoaded do
            task.wait(fw.Config.remoteFlushInterval)
            if #self.queue > 0 then
                self:Flush()
            end
        end
    end)
end

function RemoteQueueModule:Add(remote, ...)
    table.insert(self.queue, {remote = remote, args = {...}})
    
    if #self.queue >= self.framework.Config.maxRemoteBatch then
        self:Flush()
    end
end

function RemoteQueueModule:Flush()
    if self.isProcessing then return end
    self.isProcessing = true
    
    local batch = self.queue
    self.queue = {}
    
    for _, call in ipairs(batch) do
        pcall(function()
            if call.remote:IsA("RemoteEvent") then
                call.remote:FireServer(table.unpack(call.args))
            else
                call.remote:InvokeServer(table.unpack(call.args))
            end
        end)
    end
    
    self.isProcessing = false
end

Framework:RegisterModule("RemoteQueue", RemoteQueueModule)

-- Deobfuscation
local deobfuscated = 0
for _, v in pairs(getgc(true)) do
    if typeof(v) == "table" then
        if rawget(v, "Remote") then
            if v.Remote.Name == "" or v.Remote.Name ~= v.Name then
                v.Remote.Name = v.Name
                deobfuscated = deobfuscated + 1
            end
        end
    end
end

-- UI Initialization
local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

Framework.UI.Library = Library
Framework.UI.Options = Library.Options
Framework.UI.Toggles = Library.Toggles

-- Get game name
local gameName = "Tap Simulator"
pcall(function()
    local gameInfo = MarketplaceService:GetProductInfo(game.PlaceId)
    if gameInfo and gameInfo.Name then
        gameName = gameInfo.Name
    end
end)

-- Create Window
local Window = Library:CreateWindow({
    Title = gameName,
    Footer = "v2.0.0 - Optimized & Modular",
    ToggleKeybind = Enum.KeyCode.RightControl,
    Center = true,
    AutoShow = true,
    Resizable = true,
    Size = UDim2.fromOffset(650, 450)
})
Framework.UI.Window = Window

-- Create Tabs
Framework.UI.Tabs.Farm = Window:AddTab("Farming", "sprout")
Framework.UI.Tabs.Egg = Window:AddTab("Eggs", "egg")
Framework.UI.Tabs.Machines = Window:AddTab("Machines", "cog")
Framework.UI.Tabs.Enchanting = Window:AddTab("Enchanting", "zap")
Framework.UI.Tabs.Pets = Window:AddTab("Pets", "sparkles")
Framework.UI.Tabs.Misc = Window:AddTab("Misc", "layers")
Framework.UI.Tabs.Settings = Window:AddTab("Settings", "settings")

-- Override notifications with filtering
local OriginalNotify = Library.Notify
Library.Notify = function(self, text, duration)
    if not Framework.UI.Toggles.ShowNotifications or not Framework.UI.Toggles.ShowNotifications.Value then
        return
    end
    
    -- Check notification filters
    local filters = Framework.State.notificationFilters
    local textLower = string.lower(text)
    
    -- Craft notifications
    if (textLower:find("craft") or textLower:find("golden") or textLower:find("rainbow")) and not filters.showCraft then
        return
    end
    
    -- Rebirth notifications
    if textLower:find("rebirth") and not filters.showRebirth then
        return
    end
    
    -- Hatch notifications
    if (textLower:find("hatch") or textLower:find("egg") or textLower:find("inventory")) and not filters.showHatch then
        return
    end
    
    -- Upgrade notifications
    if (textLower:find("upgrade") or textLower:find("bought")) and not filters.showUpgrade then
        return
    end
    
    -- Portal notifications
    if (textLower:find("portal") or textLower:find("unlock")) and not filters.showPortal then
        return
    end
    
    -- If no specific filter matched, check general
    if filters.showGeneral then
        OriginalNotify(self, text, duration)
    end
end

print("‚úì Framework initialized with " .. deobfuscated .. " remotes deobfuscated")
print("‚úì Loading game data modules...")

-- Data Loader Module
local DataLoaderModule = {}

function DataLoaderModule:Init(fw)
    self.framework = fw
    self:LoadPetStats()
    self:LoadCurrency()
    self:LoadEggs()
    self:LoadRebirths()
    self:LoadPortals()
    self:LoadGemShopUpgrades()
    self:LoadEnchantData()
    self:LoadReplicationData()
    self:FindRemotes()
end

function DataLoaderModule:LoadPetStats()
    local petStatsFolder = rs:FindFirstChild("Game")
    if not petStatsFolder then return end
    
    local petStatsModule = petStatsFolder:FindFirstChild("PetStats")
    if not petStatsModule then return end
    
    local petsModule = petStatsModule:FindFirstChild("Pets")
    local raritiesModule = petStatsModule:FindFirstChild("Rarities")
    local tiersModule = petStatsModule:FindFirstChild("Tiers")
    
    if petsModule and petsModule:IsA("ModuleScript") then
        pcall(function()
            self.framework.Data.petStats = require(petsModule)
        end)
    end
    
    if raritiesModule and raritiesModule:IsA("ModuleScript") then
        pcall(function()
            self.framework.Data.petRarities = require(raritiesModule)
        end)
    end
    
    if tiersModule and tiersModule:IsA("ModuleScript") then
        pcall(function()
            self.framework.Data.petTiers = require(tiersModule)
        end)
    end
end

function DataLoaderModule:GetAllRarities()
    local rarities = {}
    local raritySet = {}
    
    -- Get rarities from petStats (each pet has a Rarity field)
    if self.framework.Data.petStats then
        for petName, petData in pairs(self.framework.Data.petStats) do
            if typeof(petData) == "table" and petData.Rarity then
                local rarity = petData.Rarity
                if not raritySet[rarity] then
                    raritySet[rarity] = true
                    table.insert(rarities, rarity)
                end
            end
        end
    end
    
    -- Also check petRarities module if it exists
    if self.framework.Data.petRarities then
        for rarity, _ in pairs(self.framework.Data.petRarities) do
            if typeof(rarity) == "string" and not raritySet[rarity] then
                raritySet[rarity] = true
                table.insert(rarities, rarity)
            end
        end
    end
    
    -- Sort rarities by rank for better UX
    table.sort(rarities, function(a, b)
        local rankA = self.framework:GetModule("GameHelper"):GetRarityRank(a)
        local rankB = self.framework:GetModule("GameHelper"):GetRarityRank(b)
        return rankA < rankB
    end)
    
    return rarities
end

function DataLoaderModule:LoadCurrency()
    local currencyModule = rs:FindFirstChild("Game")
    if not currencyModule then return end
    
    local currMod = currencyModule:FindFirstChild("Currency")
    if currMod and currMod:IsA("ModuleScript") then
        pcall(function()
            local currencyData = require(currMod)
            for currName, currInfo in pairs(currencyData) do
                if currInfo.Name then
                    self.framework.Data.primaryCurrency = currInfo.Name
                    break
                end
            end
        end)
    end
end

function DataLoaderModule:LoadEggs()
    local eggFolder = rs:FindFirstChild("Game")
    if not eggFolder then return end
    
    eggFolder = eggFolder:FindFirstChild("Eggs")
    if not eggFolder or not eggFolder:IsA("ModuleScript") then return end
    
    local success, result = pcall(function()
        return require(eggFolder)
    end)
    
    if not success or typeof(result) ~= "table" then return end
    
    for eggName, eggInfo in pairs(result) do
        if typeof(eggInfo) == "table" then
            local isRobuxEgg = eggInfo.RobuxEgg or eggInfo.robuxEgg or false
            local isExclusive = eggInfo.Exclusive or eggInfo.exclusive or false
            local isCache = string.lower(eggName) == "cache"
            
            if not isRobuxEgg and not isExclusive and not isCache then
                local price = eggInfo.Price or eggInfo.price or eggInfo.Cost or eggInfo.cost or 0
                
                self.framework.Data.eggData[eggName] = {
                    Name = eggName,
                    Price = price
                }
                
                self.framework.Data.eggPetsData[eggName] = {}
                
                if eggInfo.Pets or eggInfo.pets then
                    local petList = eggInfo.Pets or eggInfo.pets
                    
                    if typeof(petList) == "table" then
                        for petName, petChance in pairs(petList) do
                            if typeof(petName) == "string" and typeof(petChance) == "number" then
                                local petData = self.framework.Data.petStats[petName]
                                local rarity = petData and petData.Rarity or "Unknown"
                                
                                table.insert(self.framework.Data.eggPetsData[eggName], {
                                    Name = petName,
                                    Chance = petChance,
                                    Rarity = rarity,
                                    Display = petName .. " [" .. rarity .. "] (" .. petChance .. "%)",
                                    IsSecret = false
                                })
                            end
                        end
                    end
                end
                
                if eggInfo.Secrets or eggInfo.secrets then
                    local secretList = eggInfo.Secrets or eggInfo.secrets
                    
                    if typeof(secretList) == "table" then
                        for petName, secretChance in pairs(secretList) do
                            if typeof(petName) == "string" and typeof(secretChance) == "number" then
                                local percentChance = (1 / secretChance) * 100
                                local displayChance = "1/" .. self.framework:GetModule("Format"):FormatNumber(secretChance)
                                
                                table.insert(self.framework.Data.eggPetsData[eggName], {
                                    Name = petName,
                                    Chance = percentChance,
                                    SecretChance = secretChance,
                                    Rarity = "Secret",
                                    Display = petName .. " [Secret] (" .. displayChance .. ")",
                                    IsSecret = true
                                })
                            end
                        end
                    end
                end
            end
        end
    end
    
    local eggListWithPrices = {}
    for eggName, eggInfo in pairs(self.framework.Data.eggData) do
        table.insert(eggListWithPrices, {
            name = eggName,
            price = eggInfo.Price
        })
    end
    
    table.sort(eggListWithPrices, function(a, b)
        return a.price < b.price
    end)
    
    for _, egg in ipairs(eggListWithPrices) do
        local displayName = egg.name .. " (" .. self.framework:GetModule("Format"):FormatNumber(egg.price) .. " " .. string.lower(self.framework.Data.primaryCurrency) .. ")"
        table.insert(self.framework.Data.eggList, displayName)
    end
    
    if #self.framework.Data.eggList == 0 then
        self.framework.Data.eggList = {"Basic (0 clicks)"}
    end
end

function DataLoaderModule:LoadRebirths()
    -- Clear existing data
    self.framework.Data.rebirthList = {}
    self.framework.Data.rebirthData = {}
    
    local rebirthFolder = rs:FindFirstChild("Game")
    local rebirthModule = nil
    local rebirthCalculator = {
        Modifier = 1000,
        GrowthFactor = 0.15
    }
    
    if rebirthFolder then
        rebirthModule = rebirthFolder:FindFirstChild("Rebirths")
    end
    
    if rebirthModule and rebirthModule:IsA("ModuleScript") then
        local success, result = pcall(function()
            return require(rebirthModule)
        end)
        
        if success and typeof(result) == "table" then
            rebirthCalculator = result
        end
    end
    
    local function getRebirthAmountFromIndex(index)
        if rebirthCalculator.fromIndex then
            return rebirthCalculator:fromIndex(index)
        else
            local v4 = index - 1
            local v_u_2 = {1, 5, 15, 35, 70}
            local v5 = v_u_2[v4 % 5 + 1]
            local v6 = v4 / 5
            return v5 * 100 ^ math.floor(v6)
        end
    end
    
    -- Always add "Max Unlocked" option
    table.insert(self.framework.Data.rebirthList, "Max Unlocked")
    
    -- Count how many rebirth buttons exist in the UI
    local rebirthCount = 0
    pcall(function()
        local rebirthListUI = p.PlayerGui.RightHud.Main.RightUI.Rebirths.List
        if rebirthListUI then
            for _, child in pairs(rebirthListUI:GetChildren()) do
                if child:IsA("Frame") or child:IsA("GuiObject") then
                    local rebirthNum = tonumber(child.Name)
                    if rebirthNum and rebirthNum > rebirthCount then
                        rebirthCount = rebirthNum
                    end
                end
            end
        end
    end)
    
    -- If we couldn't find any, default to at least 10
    if rebirthCount == 0 then
        rebirthCount = 10
    end
    
    -- Load only the rebirths that actually exist
    for i = 1, rebirthCount do
        local amount = getRebirthAmountFromIndex(i)
        local displayText = self.framework:GetModule("Format"):FormatNumber(amount) .. " Rebirths"
        table.insert(self.framework.Data.rebirthList, displayText)
        
        self.framework.Data.rebirthData[i] = {
            Index = i,
            Amount = amount
        }
    end
end

function DataLoaderModule:RefreshRebirthList()
    -- Re-scan for available rebirths
    local newRebirthCount = 0
    pcall(function()
        local rebirthListUI = p.PlayerGui.RightHud.Main.RightUI.Rebirths.List
        if rebirthListUI then
            for _, child in pairs(rebirthListUI:GetChildren()) do
                if child:IsA("Frame") or child:IsA("GuiObject") then
                    local rebirthNum = tonumber(child.Name)
                    if rebirthNum and rebirthNum > newRebirthCount then
                        newRebirthCount = rebirthNum
                    end
                end
            end
        end
    end)
    
    -- Only update if count changed
    local currentCount = #self.framework.Data.rebirthList - 1 -- -1 for "Max Unlocked"
    if newRebirthCount > 0 and newRebirthCount ~= currentCount then
        self:LoadRebirths()
        
        -- Update the dropdown if it exists
        if self.framework.UI.Options.RebirthAmount then
            self.framework.UI.Options.RebirthAmount:SetValues(self.framework.Data.rebirthList)
        end
        
        return true
    end
    
    return false
end

function DataLoaderModule:LoadPortals()
    local portalsModule = rs:FindFirstChild("Game")
    if not portalsModule then return end
    
    local portals = portalsModule:FindFirstChild("Portals")
    if not portals or not portals:IsA("ModuleScript") then return end
    
    local success, result = pcall(function()
        return require(portals)
    end)
    
    if not success or typeof(result) ~= "table" then return end
    
    self.framework.Data.portalsData = result
    
    local portalArray = {}
    for portalName, portalInfo in pairs(result) do
        table.insert(portalArray, {
            name = portalName,
            price = portalInfo.Price or 0,
            multi = portalInfo.Multi or 1
        })
    end
    
    table.sort(portalArray, function(a, b)
        return a.multi < b.multi
    end)
    
    for _, portal in ipairs(portalArray) do
        local displayText = portal.name .. " (" .. portal.multi .. "x Boost)"
        table.insert(self.framework.Data.portalsList, displayText)
    end
end

function DataLoaderModule:LoadGemShopUpgrades()
    local gemShopList = nil
    pcall(function()
        gemShopList = p.PlayerGui.Tabs.Upgrades.Menu.Categories.Upgrades.Inner.List
    end)
    
    if gemShopList then
        for _, child in pairs(gemShopList:GetChildren()) do
            if child:IsA("Frame") and child.Name ~= "UIListLayout" and child.Name ~= "Template" then
                -- Format the name with proper spacing
                local displayName = child.Name:gsub("(%u)", " %1"):gsub("^%s+", "")
                self.framework.Data.gemShopUpgrades[displayName] = child.Name
            end
        end
    end
end

function DataLoaderModule:LoadEnchantData()
    local enchantModule = rs:FindFirstChild("Game")
    if not enchantModule then return end
    
    enchantModule = enchantModule:FindFirstChild("EnchantData")
    if not enchantModule or not enchantModule:IsA("ModuleScript") then return end
    
    local success, result = pcall(function()
        return require(enchantModule)
    end)
    
    if success and typeof(result) == "table" then
        self.framework.Data.enchantData = result
        
        -- Build sorted list of enchants with chances
        self.framework.Data.enchantList = {}
        if result.Contents then
            for enchantName, chance in pairs(result.Contents) do
                table.insert(self.framework.Data.enchantList, {
                    name = enchantName,
                    chance = chance,
                    display = enchantName .. " (" .. chance .. "%)"
                })
            end
            
            -- Sort by chance (rarest first)
            table.sort(self.framework.Data.enchantList, function(a, b)
                return a.chance < b.chance
            end)
        end
    end
end

function DataLoaderModule:LoadReplicationData()
    local replicationModule = rs:FindFirstChild("Game")
    if not replicationModule then return end
    
    local repMod = replicationModule:FindFirstChild("Replication")
    if repMod and repMod:IsA("ModuleScript") then
        pcall(function()
            self.framework.Data.replicationData = require(repMod)
        end)
    end
end

function DataLoaderModule:FindRemotes()
    local eventsFolder = nil
    
    for _, child in pairs(rs:GetChildren()) do
        if string.match(child.Name, "%x+-%x+-%x+-%x+") then
            if child:FindFirstChild("Events") or child:FindFirstChild("Functions") then
                eventsFolder = child
                break
            end
        end
    end
    
    if not eventsFolder then
        for _, child in pairs(rs:GetChildren()) do
            if child:FindFirstChild("Events") or child:FindFirstChild("Functions") then
                eventsFolder = child
                break
            end
        end
    end
    
    if not eventsFolder then
        error("Could not find game folder!")
    end
    
    local events = eventsFolder:FindFirstChild("Events")
    local functions = eventsFolder:FindFirstChild("Functions")
    
    if not events then
        error("Could not find Events folder!")
    end
    
    self.framework.Remotes = {
        tap = events:FindFirstChild("Tap"),
        rebirth = functions and functions:FindFirstChild("Rebirth"),
        openEgg = functions and functions:FindFirstChild("OpenEgg"),
        buyUpgrade = functions and functions:FindFirstChild("UpgradeGemShop"),
        doubleJump = functions and functions:FindFirstChild("UpgradeDoubleJump"),
        autoDelete = events and events:FindFirstChild("AutoDelete"),
        craftPets = functions and functions:FindFirstChild("CraftPets"),
        startRainbow = functions and functions:FindFirstChild("StartRainbow"),
        claimRainbow = functions and functions:FindFirstChild("ClaimRainbow"),
        enchantPet = functions and functions:FindFirstChild("EnchantPet"),
        teleport = functions and functions:FindFirstChild("TeleportZone"),
        BuyPortal = functions and functions:FindFirstChild("BuyPortal")  -- ADD THIS LINE
    }
end

Framework:RegisterModule("DataLoader", DataLoaderModule)

-- Game Helper Module
local GameHelperModule = {
    rarityRank = {
        ["Basic"] = 1, ["Common"] = 1,
        ["Uncommon"] = 2, ["Rare"] = 2,
        ["Epic"] = 3,
        ["Legendary"] = 4,
        ["Mythical"] = 5, ["Mythic"] = 5,
        ["Divine"] = 6, ["Godly"] = 6,
        ["Celestial"] = 7, ["Leaderboard"] = 7,
        ["Exclusive"] = 8,
        ["Secret"] = 9,
        ["Secret I"] = 10, ["Secret II"] = 11,
        ["Secret III"] = 12, ["Secret IV"] = 13,
        ["Secret V"] = 14,
        ["Unknown"] = 0
    }
}

function GameHelperModule:Init(fw)
    self.framework = fw
end

function GameHelperModule:GetRarityRank(rarity)
    return self.rarityRank[rarity] or self.rarityRank["Unknown"] or 0
end

-- Currency from replication data (MUCH more reliable than UI parsing)
function GameHelperModule:GetClicksFromData()
    local success, clicks = pcall(function()
        if self.framework.Data.replicationData and 
           self.framework.Data.replicationData.Data and 
           self.framework.Data.replicationData.Data.Statistics then
            return self.framework.Data.replicationData.Data.Statistics.Clicks or 0
        end
        return 0
    end)
    return success and clicks or 0
end

function GameHelperModule:GetGemsFromData()
    local success, gems = pcall(function()
        if self.framework.Data.replicationData and 
           self.framework.Data.replicationData.Data and 
           self.framework.Data.replicationData.Data.Statistics then
            return self.framework.Data.replicationData.Data.Statistics.Gems or 0
        end
        return 0
    end)
    return success and gems or 0
end

-- Inventory limit (no more UI parsing!)
function GameHelperModule:GetMaxInventoryFromData()
    local success, max = pcall(function()
        if self.framework.Data.replicationData and 
           self.framework.Data.replicationData.Data then
            return self.framework.Data.replicationData.Data.StorageLimit or 100
        end
        return 100
    end)
    return success and max or 100
end

-- Check if egg is unlocked
function GameHelperModule:IsEggUnlocked(eggName)
    local success, unlocked = pcall(function()
        if self.framework.Data.replicationData and 
           self.framework.Data.replicationData.Data and 
           self.framework.Data.replicationData.Data.UnlockedEggs then
            return self.framework.Data.replicationData.Data.UnlockedEggs[eggName] == true
        end
        return false
    end)
    return success and unlocked or false
end

-- Get enchant crystals
function GameHelperModule:GetEnchantCrystalsFromData()
    local success, crystals = pcall(function()
        if self.framework.Data.replicationData and 
           self.framework.Data.replicationData.Data and 
           self.framework.Data.replicationData.Data.Items then
            return self.framework.Data.replicationData.Data.Items.EnchantCrystal or 0
        end
        return 0
    end)
    return success and crystals or 0
end

-- Check gamepasses
function GameHelperModule:HasGamepass(gamepassName)
    local success, hasPass = pcall(function()
        if self.framework.Data.replicationData and 
           self.framework.Data.replicationData.Data and 
           self.framework.Data.replicationData.Data.Gamepasses then
            return self.framework.Data.replicationData.Data.Gamepasses[gamepassName] == true
        end
        return false
    end)
    return success and hasPass or false
end

-- Debug function to find max inventory field
function GameHelperModule:DebugInventoryFields()
    local results = {}
    
    pcall(function()
        local replicationModule = rs:FindFirstChild("Game")
        if not replicationModule then return end
        
        local repMod = replicationModule:FindFirstChild("Replication")
        if not repMod or not repMod:IsA("ModuleScript") then return end
        
        local freshData = require(repMod)
        if not freshData or not freshData.Data then return end
        
        local data = freshData.Data
        
        -- Search for any field containing numbers that might be max inventory
        local function searchTable(t, path, depth)
            if depth > 3 then return end -- Limit recursion
            
            for key, value in pairs(t) do
                local currentPath = path == "" and tostring(key) or (path .. "." .. tostring(key))
                local valueType = type(value)
                
                -- Look for numeric values between 100-1000 (likely max inventory range)
                if valueType == "number" then
                    if value >= 100 and value <= 10000 then
                        table.insert(results, {
                            path = currentPath,
                            value = value,
                            type = "number"
                        })
                    end
                elseif valueType == "table" then
                    -- Check if table has Value field
                    if value.Value and type(value.Value) == "number" then
                        if value.Value >= 100 and value.Value <= 10000 then
                            table.insert(results, {
                                path = currentPath .. ".Value",
                                value = value.Value,
                                type = "table.Value"
                            })
                        end
                    end
                    -- Recurse into table
                    if depth < 3 then
                        searchTable(value, currentPath, depth + 1)
                    end
                end
            end
        end
        
        searchTable(data, "", 0)
    end)
    
    -- Print results to console
    print("=== INVENTORY MAX DEBUG ===")
    print("Found " .. #results .. " potential max inventory fields:")
    for i, result in ipairs(results) do
        print(i .. ". " .. result.path .. " = " .. result.value .. " (" .. result.type .. ")")
    end
    print("===========================")
    
    return results
end

function GameHelperModule:GetInventorySpace()
    local current = 0
    local max = self:GetMaxInventoryFromData() -- Use new function!
    
    -- Get from replication data (server-sided and most reliable)
    local success = pcall(function()
        if self.framework.Data.replicationData and 
           self.framework.Data.replicationData.Data then
            local data = self.framework.Data.replicationData.Data
            
            -- Count current pets
            if data.Pets then
                for _ in pairs(data.Pets) do
                    current = current + 1
                end
            end
        end
    end)
    
    if success and current >= 0 and max > 0 then
        return current, max
    end
    
    -- Fallback: Parse from UI if replication data failed
    local uiSuccess = pcall(function()
        local inventoryUI = p.PlayerGui.Tabs.Inventory.Menu.Categories.Pets.Top.Storage
        if not inventoryUI then return end
        
        local text = inventoryUI.Text
        if not text or text == "" then return end
        
        local curr, mx = string.match(text, "(%d+)%s*/%s*(%d+)")
        
        if curr and mx then
            local currentNum = tonumber(curr)
            local maxNum = tonumber(mx)
            
            if currentNum and maxNum and maxNum ~= 999 then
                current = currentNum
                max = maxNum
            end
        end
    end)
    
    return current, max
end

    function GameHelperModule:RefreshInventoryCache()
    -- Force refresh inventory data by temporarily enabling UI if needed
    pcall(function()
        local invTab = p.PlayerGui.Tabs.Inventory
        if not invTab.Enabled then
            invTab.Enabled = true
            task.wait(0.05)
            invTab.Enabled = false
        end
    end)
    
    -- Invalidate related caches
    self.framework:GetModule("Cache"):Invalidate("ownedPetCounts")
    self.framework:GetModule("Cache"):Invalidate("allGamePets")
end

function GameHelperModule:IsInventoryFull(buffer)
    buffer = buffer or 5
    local current, max = self:GetInventorySpace()
    
    if not current or not max or max == 0 then
        return false
    end
    
    return current >= (max - buffer)
end

function GameHelperModule:GetAvailableInventorySpace()
    local current, max = self:GetInventorySpace()
    
    if not current or not max then
        return 100
    end
    
    return math.max(0, max - current)
end

function GameHelperModule:GetCurrentClicks()
    -- Try to get from replication data first (more reliable)
    local clicksFromData = self:GetClicksFromData()
    if clicksFromData > 0 then
        return clicksFromData
    end
    
    -- Fallback to UI parsing if replication data not available
    local clicksLabel = p.PlayerGui:FindFirstChild("Game")
    if not clicksLabel then return 0 end
    clicksLabel = clicksLabel:FindFirstChild("Left")
    if not clicksLabel then return 0 end
    clicksLabel = clicksLabel:FindFirstChild("Clicks")
    if not clicksLabel then return 0 end
    clicksLabel = clicksLabel:FindFirstChild("Main")
    if not clicksLabel then return 0 end
    clicksLabel = clicksLabel:FindFirstChild("Amount")
    if not clicksLabel then return 0 end
    
    local clicksText = string.gsub(clicksLabel.Text, ",", "")
    local numPart = tonumber(string.match(clicksText, "([%d%.]+)"))
    if not numPart then return 0 end
    
    local suffix = string.match(clicksText, "([KMBTQSNODUXPCkmbtqsnoduxpc]+)")
    if suffix then
        suffix = string.upper(suffix)
        local multipliers = {
            K = 1e3, M = 1e6, B = 1e9, T = 1e12,
            QD = 1e15, QN = 1e18, SX = 1e21, SP = 1e24,
            O = 1e27, N = 1e30, DC = 1e33, UD = 1e36,
            DD = 1e39, TD = 1e42
        }
        return numPart * (multipliers[suffix] or 1)
    else
        return numPart
    end
end

function GameHelperModule:CanAffordEgg(eggName, amount)
    local eggCost = 0
    if self.framework.Data.eggData[eggName] then
        eggCost = self.framework.Data.eggData[eggName].Price
    else
        return false
    end
    
    local totalCost = eggCost * amount
    local currentClicks = self:GetCurrentClicks()
    
    return currentClicks >= totalCost
end

function GameHelperModule:GetBestAffordableEgg()
    local currentClicks = self:GetCurrentClicks()
    
    if currentClicks <= 0 then
        return nil, 0, 0
    end
    
    local bestEgg = nil
    local bestPrice = 0
    local bestAvgMultiplier = 0
    
    -- Find the egg with the best average multiplier that we can afford
    for eggName, eggInfo in pairs(self.framework.Data.eggData) do
        local price = eggInfo.Price
        
        if price <= currentClicks then
            -- Calculate average multiplier for this egg
            local avgMultiplier = self:GetEggAverageMultiplier(eggName)
            
            -- Select this egg if it has a higher average multiplier
            -- OR if it has the same multiplier but is more expensive (tiebreaker)
            if avgMultiplier > bestAvgMultiplier or 
               (avgMultiplier == bestAvgMultiplier and price > bestPrice) then
                bestAvgMultiplier = avgMultiplier
                bestPrice = price
                bestEgg = eggName
            end
        end
    end
    
    return bestEgg, bestPrice, bestAvgMultiplier
end

function GameHelperModule:GetEggAverageMultiplier(eggName)
    local pets = self.framework.Data.eggPetsData[eggName]
    if not pets or #pets == 0 then return 0 end
    
    local totalMultiplier = 0
    local totalChance = 0
    
    for _, petData in ipairs(pets) do
        local petStats = self.framework.Data.petStats[petData.Name]
        local multiplier = petStats and petStats.Multiplier1 or 0
        local chance = petData.Chance or 0
        
        -- Weight by chance (so rarer pets with higher multipliers don't skew the average too much)
        totalMultiplier = totalMultiplier + (multiplier * chance)
        totalChance = totalChance + chance
    end
    
    if totalChance == 0 then return 0 end
    
    return totalMultiplier / totalChance
end

function GameHelperModule:GetCurrentIslandMultiplier()
    local success, multiplier = pcall(function()
        local label = p.PlayerGui.Game.Active.IslandMultiplier.Label
        if not label then return 1 end
        
        local text = label.Text
        if not text then return 1 end
        
        local percent = tonumber(string.match(text, "([%d%.]+)%%?"))
        if percent then
            return (percent / 100) + 1
        end
        
        local num = tonumber(string.match(text, "([%d%.]+)x?"))
        return num or 1
    end)
    
    return success and multiplier or 1
end

function GameHelperModule:GetPetTierFromFrame(petFrame)
    local viewportFrame = petFrame:FindFirstChild("Main")
    if viewportFrame then
        viewportFrame = viewportFrame:FindFirstChild("ViewportFrame")
        if viewportFrame then
            local imageColor = viewportFrame.ImageColor3
            
            if imageColor then
                local isNotWhite = (imageColor.R < 0.95 or imageColor.G < 0.95 or imageColor.B < 0.95)
                
                if isNotWhite then
                    local maxComponent = math.max(imageColor.R, imageColor.G, imageColor.B)
                    local minComponent = math.min(imageColor.R, imageColor.G, imageColor.B)
                    local saturation = maxComponent - minComponent
                    
                    if saturation > 0.1 then
                        return "Rainbow"
                    end
                end
            end
        end
    end
    
    local gradient = petFrame:FindFirstChildOfClass("UIGradient", true)
    
    if gradient then
        local rotation = gradient.Rotation
        local color = gradient.Color
        
        if rotation == 90 then
            for _, keypoint in ipairs(color.Keypoints) do
                local c = keypoint.Value
                if c.R > 0.6 and c.G > 0.5 and c.B < 0.3 then
                    return "Golden"
                end
            end
        end
    end
    
    return "Normal"
end

function GameHelperModule:GetBestPetFromEgg(eggName)
    local pets = self.framework.Data.eggPetsData[eggName]
    if not pets or #pets == 0 then return "Unknown" end
    
    local bestNormalPet = nil
    local bestNormalMultiplier = 0
    local secretPets = {}
    
    -- Separate secrets from normal pets and collect ALL secrets
    for _, petData in ipairs(pets) do
        if petData.IsSecret then
            table.insert(secretPets, petData)
        else
            -- For normal pets, find the one with highest multiplier
            local petStatsData = self.framework.Data.petStats[petData.Name]
            if petStatsData then
                local multiplier = petStatsData.Multiplier1 or 0
                if multiplier > bestNormalMultiplier then
                    bestNormalMultiplier = multiplier
                    bestNormalPet = petData
                end
            end
        end
    end
    
    -- If we have secrets, pick the rarest one (highest secret chance number = rarest)
    local bestPet = nil
    if #secretPets > 0 then
        -- Sort by rarity (highest SecretChance = rarest)
        table.sort(secretPets, function(a, b)
            return (a.SecretChance or 0) > (b.SecretChance or 0)
        end)
        bestPet = secretPets[1] -- Pick the rarest secret
    else
        bestPet = bestNormalPet
    end
    
    if not bestPet then
        return "Unknown"
    end
    
    -- Get pet stats
    local petStatsData = self.framework.Data.petStats[bestPet.Name]
    if not petStatsData then
        -- Even without stats, show what we know
        local chanceDisplay = ""
        if bestPet.IsSecret then
            chanceDisplay = "1/" .. self.framework:GetModule("Format"):FormatNumber(bestPet.SecretChance)
        else
            chanceDisplay = bestPet.Chance .. "%"
        end
        return bestPet.Name .. " [Secret] (" .. chanceDisplay .. ", Unknown power)"
    end
    
    -- Determine rarity
    local rarity = petStatsData.Rarity or "Unknown"
    
    -- Determine power display
    local multiplierDisplay = ""
    
    if petStatsData.Percentage and petStatsData.Percentage > 0 then
        -- Percentage-based pet (e.g., Divine Celestia with 125% of best pet)
        multiplierDisplay = petStatsData.Percentage .. "% of best"
    elseif petStatsData.Multiplier1 and petStatsData.Multiplier1 > 0 then
        -- Fixed multiplier pet
        multiplierDisplay = self.framework:GetModule("Format"):FormatNumber(petStatsData.Multiplier1) .. "x"
    else
        -- Fallback - pet might still be valid but has unusual data structure
        multiplierDisplay = "Special"
    end
    
    -- Format chance display
    local chanceDisplay = ""
    if bestPet.IsSecret then
        chanceDisplay = "1/" .. self.framework:GetModule("Format"):FormatNumber(bestPet.SecretChance)
    else
        chanceDisplay = bestPet.Chance .. "%"
    end
    
    return bestPet.Name .. " [" .. rarity .. "] (" .. chanceDisplay .. ", " .. multiplierDisplay .. ")"
end

function GameHelperModule:DebugReplicationData()
    local output = {}
    table.insert(output, "=== REPLICATION DATA DEBUG ===\n")
    
    pcall(function()
        local replicationModule = rs:FindFirstChild("Game")
        if not replicationModule then 
            table.insert(output, "‚ùå Game folder not found\n")
            return 
        end
        
        local repMod = replicationModule:FindFirstChild("Replication")
        if not repMod or not repMod:IsA("ModuleScript") then 
            table.insert(output, "‚ùå Replication module not found\n")
            return 
        end
        
        local freshData = require(repMod)
        if not freshData or not freshData.Data then 
            table.insert(output, "‚ùå No data in replication module\n")
            return 
        end
        
        local data = freshData.Data
        
        table.insert(output, "‚úì Replication Data Found!\n")
        table.insert(output, "=========================\n")
        
        -- Function to safely format values
        local function formatValue(name, value, indent)
            indent = indent or ""
            local valueType = type(value)
            local result = {}
            
            if valueType == "number" then
                table.insert(result, indent .. name .. " = " .. tostring(value) .. " (number)\n")
            elseif valueType == "string" then
                table.insert(result, indent .. name .. ' = "' .. value .. '" (string)\n')
            elseif valueType == "boolean" then
                table.insert(result, indent .. name .. " = " .. tostring(value) .. " (boolean)\n")
            elseif valueType == "table" then
                table.insert(result, indent .. name .. " = { (table)\n")
                -- Only go 2 levels deep to avoid spam
                if indent == "" then
                    for k, v in pairs(value) do
                        for _, line in ipairs(formatValue(tostring(k), v, "  ")) do
                            table.insert(result, line)
                        end
                    end
                end
                table.insert(result, indent .. "}\n")
            else
                table.insert(result, indent .. name .. " = " .. tostring(value) .. " (" .. valueType .. ")\n")
            end
            
            return result
        end
        
        -- Print top-level data fields
        table.insert(output, "\nüìä TOP LEVEL FIELDS:\n")
        for key, value in pairs(data) do
            for _, line in ipairs(formatValue(tostring(key), value)) do
                table.insert(output, line)
            end
        end
        
        -- Specifically look for currency-related fields
        table.insert(output, "\nüí∞ CURRENCY FIELDS:\n")
        local currencyFields = {"Clicks", "Gems", "Coins", "Money", "Currency", "Cash", "Gold"}
        for _, field in ipairs(currencyFields) do
            if data[field] ~= nil then
                table.insert(output, "‚úì " .. field .. " = " .. tostring(data[field]) .. "\n")
            end
        end
        
        -- Look for stat-related fields
        table.insert(output, "\nüìà STAT FIELDS:\n")
        local statFields = {"Stats", "PlayerStats", "Rebirths", "Level", "Rank", "Prestige"}
        for _, field in ipairs(statFields) do
            if data[field] ~= nil then
                for _, line in ipairs(formatValue(field, data[field])) do
                    table.insert(output, line)
                end
            end
        end
        
    end)
    
    table.insert(output, "\n=== END DEBUG ===")
    
    -- Combine all output and copy to clipboard
    local fullOutput = table.concat(output, "")
    setclipboard(fullOutput)
    
    -- Also print to console
    print(fullOutput)
    
    return fullOutput
end

Framework:RegisterModule("GameHelper", GameHelperModule)

-- Pet Management Module
local PetManagementModule = {}

function PetManagementModule:Init(fw)
    self.framework = fw
end

function PetManagementModule:GetOwnedPetCounts()
    return self.framework:GetModule("Cache"):Get("ownedPetCounts", function()
        local ownedPetCounts = {}
        
        pcall(function()
            local container = p.PlayerGui.Tabs.Inventory.Menu.Categories.Pets.Inner.List.Container
            if container then
                for _, child in pairs(container:GetChildren()) do
                    if child:IsA("Frame") and child.Name ~= "UIListLayout" and child.Name ~= "UIAspectRatioConstraint" and child.Name ~= "UICorner" and child.Name ~= "Template" then
                        local petName = child.Name
                        local tier = self.framework:GetModule("GameHelper"):GetPetTierFromFrame(child)
                        
                        local key = petName .. "|" .. tier
                        ownedPetCounts[key] = (ownedPetCounts[key] or 0) + 1
                    end
                end
            end
        end)
        
        pcall(function()
            local equipped = p.PlayerGui.Tabs.Inventory.Menu.Categories.Pets.Inner.List.Equipped.List
            if equipped then
                for _, child in pairs(equipped:GetChildren()) do
                    if child:IsA("Frame") and child.Name ~= "UIListLayout" and child.Name ~= "UIAspectRatioConstraint" and child.Name ~= "UICorner" and child.Name ~= "Template" and child.Name ~= "Pet" then
                        local petName = child.Name
                        local tier = self.framework:GetModule("GameHelper"):GetPetTierFromFrame(child)
                        
                        local key = petName .. "|" .. tier
                        ownedPetCounts[key] = (ownedPetCounts[key] or 0) + 1
                    end
                end
            end
        end)
        
        return ownedPetCounts
    end, 2)
end

-- Inventory Loader Module (One-Time Check)
local InventoryLoaderModule = {
    hasBeenOpened = false
}

function InventoryLoaderModule:Init(fw)
    self.framework = fw
end

function InventoryLoaderModule:IsInventoryDataLoaded()
    local success, isLoaded = pcall(function()
        local inventoryUI = p.PlayerGui.Tabs.Inventory.Menu.Categories.Pets.Top.Storage
        if not inventoryUI then return false end
        
        local text = inventoryUI.Text
        if not text or text == "" then return false end
        
        -- Check if we have valid inventory data
        local curr, mx = string.match(text, "(%d+)%s*/%s*(%d+)")
        
        if not curr or not mx then return false end
        
        local currentNum = tonumber(curr)
        local maxNum = tonumber(mx)
        
        -- "999 / 999" is the placeholder for unloaded inventory
        -- Real inventory will never be exactly 999/999
        if currentNum == 999 and maxNum == 999 then
            return false -- This is placeholder data, not loaded
        end
        
        -- Valid loaded data
        return maxNum > 0 and maxNum < 999
    end)
    
    return success and isLoaded
end

function InventoryLoaderModule:EnsureInventoryLoaded()
    -- If we already checked and opened it once, don't do it again
    if self.hasBeenOpened then return true end
    
    -- Check if inventory data is already loaded (player opened it manually)
    if self:IsInventoryDataLoaded() then
        self.hasBeenOpened = true
        if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
            self.framework.UI.Library:Notify("‚úì Inventory already loaded", 2)
        end
        return true
    end
    
    -- Inventory hasn't been loaded yet, open it once
    if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
        self.framework.UI.Library:Notify("Loading inventory data...", 2)
    end
    
    local success = pcall(function()
        local inventoryTab = p.PlayerGui.Tabs.Inventory
        if inventoryTab then
            -- Open inventory
            inventoryTab.Enabled = true
            
            -- Wait just enough for data to load (almost instant)
            task.wait()  -- Changed from 0.5 to 0.05 (50ms)
            
            -- Close it immediately
            inventoryTab.Enabled = false
        end
    end)
    
    if success then
        -- Mark as opened so we never do this again
        self.hasBeenOpened = true
        
        -- Verify it actually loaded
        if self:IsInventoryDataLoaded() then
            if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
                self.framework.UI.Library:Notify("‚úì Inventory loaded successfully!", 2)
            end
            return true
        end
    end
    
    return false
end

Framework:RegisterModule("InventoryLoader", InventoryLoaderModule)

function PetManagementModule:GetAllPetsFromGame()
    return self.framework:GetModule("Cache"):Get("allGamePets", function()
        local allPets = {}
        
        if not self.framework.Data.petStats then return allPets end
        
        local ownedPetCounts = self:GetOwnedPetCounts()
        
        for petName, petData in pairs(self.framework.Data.petStats) do
            if typeof(petData) == "table" then
                local rarity = petData.Rarity or "Unknown"
                local multiplier = petData.Multiplier1 or 0
                
                local normalKey = petName .. "|Normal"
                local goldenKey = petName .. "|Golden"
                local rainbowKey = petName .. "|Rainbow"
                
                local normalCount = ownedPetCounts[normalKey] or 0
                local goldenCount = ownedPetCounts[goldenKey] or 0
                local rainbowCount = ownedPetCounts[rainbowKey] or 0
                local totalCount = normalCount + goldenCount + rainbowCount
                
                table.insert(allPets, {
                    name = petName,
                    rarity = rarity,
                    multiplier = multiplier,
                    ownedCount = totalCount,
                    normalCount = normalCount,
                    goldenCount = goldenCount,
                    rainbowCount = rainbowCount,
                    display = petName .. " [" .. rarity .. "] (" .. self.framework:GetModule("Format"):FormatNumber(multiplier) .. "x)"
                })
            end
        end
        
        table.sort(allPets, function(a, b)
            local rarityA = self.framework:GetModule("GameHelper"):GetRarityRank(a.rarity)
            local rarityB = self.framework:GetModule("GameHelper"):GetRarityRank(b.rarity)
            
            if rarityA == rarityB then
                return a.name < b.name
            else
                return rarityA < rarityB
            end
        end)
        
        return allPets
    end, 2)
end

function PetManagementModule:SortPetList(pets, sortMethod, tierFilter)
    local sorted = {}
    for _, pet in ipairs(pets) do
        table.insert(sorted, pet)
    end
    
    if sortMethod == "Multiplier (Low to High)" then
        table.sort(sorted, function(a, b) return a.multiplier < b.multiplier end)
    elseif sortMethod == "Multiplier (High to Low)" then
        table.sort(sorted, function(a, b) return a.multiplier > b.multiplier end)
    elseif sortMethod == "Owned (High to Low)" then
        table.sort(sorted, function(a, b)
            local countA = a.ownedCount
            local countB = b.ownedCount
            
            if tierFilter == "Normal" then
                countA = a.normalCount or 0
                countB = b.normalCount or 0
            elseif tierFilter == "Golden" then
                countA = a.goldenCount or 0
                countB = b.goldenCount or 0
            elseif tierFilter == "Rainbow" then
                countA = a.rainbowCount or 0
                countB = b.rainbowCount or 0
            end
            
            if countA == countB then
                return a.name < b.name
            end
            return countA > countB
        end)
    elseif sortMethod == "Owned (Low to High)" then
        table.sort(sorted, function(a, b)
            local countA = a.ownedCount
            local countB = b.ownedCount
            
            if tierFilter == "Normal" then
                countA = a.normalCount or 0
                countB = b.normalCount or 0
            elseif tierFilter == "Golden" then
                countA = a.goldenCount or 0
                countB = b.normalCount or 0
            elseif tierFilter == "Rainbow" then
                countA = a.rainbowCount or 0
                countB = b.rainbowCount or 0
            end
            
            if countA == countB then
                return a.name < b.name
            end
            return countA < countB
        end)
    end
    
    return sorted
end

function PetManagementModule:GetPlayerPetsFromData(tierFilter)
    return self.framework:GetModule("Cache"):Get("playerPets_" .. tierFilter, function()
        local pets = {}
        local petsByName = {}
        
        if not self.framework.Data.replicationData or not self.framework.Data.replicationData.Data or not self.framework.Data.replicationData.Data.Pets then
            return pets
        end
        
        for petId, petData in pairs(self.framework.Data.replicationData.Data.Pets) do
            if typeof(petData) == "table" then
                local petName = petData.Name
                local petTier = petData.Tier
                
                if petTier == tierFilter then
                    if not petsByName[petName] then
                        petsByName[petName] = {
                            name = petName,
                            count = 0,
                            ids = {}
                        }
                    end
                    
                    petsByName[petName].count = petsByName[petName].count + 1
                    table.insert(petsByName[petName].ids, petId)
                end
            end
        end
        
        for _, petData in pairs(petsByName) do
            petData.display = petData.name .. " (x" .. petData.count .. ")"
            table.insert(pets, petData)
        end
        
        table.sort(pets, function(a, b)
            return a.name < b.name
        end)
        
        return pets
    end, 1)
end

function PetManagementModule:GetPetIDsForCrafting(petName, amount, tierFilter)
    self.framework:GetModule("Cache"):Invalidate("playerPets_" .. tierFilter)
    
    local pets = self:GetPlayerPetsFromData(tierFilter)
    
    for _, petData in ipairs(pets) do
        if petData.name == petName then
            local ids = {}
            
            for i = 1, math.min(amount, #petData.ids) do
                local petId = petData.ids[i]
                
                if self.framework.Data.replicationData and self.framework.Data.replicationData.Data and self.framework.Data.replicationData.Data.Pets then
                    local actualPetData = self.framework.Data.replicationData.Data.Pets[petId]
                    if actualPetData and actualPetData.Name == petName and actualPetData.Tier == tierFilter then
                        table.insert(ids, petId)
                    end
                else
                    table.insert(ids, petId)
                end
            end
            
            return ids, petData.count
        end
    end
    
    return {}, 0
end

Framework:RegisterModule("PetManagement", PetManagementModule)

-- Portal Module
local PortalModule = {
    enabled = false,
    unlockedPortalsCache = {},
    connection = nil,
    unlockMode = "Tween" -- "Tween" or "Purchase"
}

function PortalModule:Init(fw)
    self.framework = fw
    self:StartAutoUnlockLoop()
end

function PortalModule:IsPortalLocked(portalName)
    -- Method 1: Check replication data (most reliable)
    if self.framework.Data.replicationData and self.framework.Data.replicationData.Data and self.framework.Data.replicationData.Data.Portals then
        local portals = self.framework.Data.replicationData.Data.Portals
        
        -- If portal exists in data and is true, it's unlocked
        if portals[portalName] == true then
            return false
        end
        
        -- If portal exists in data and is false/nil, it's locked
        if portals[portalName] == false or portals[portalName] == nil then
            return true
        end
    end
    
    -- Method 2: Check PortalFirstVisits (alternative check)
    if self.framework.Data.replicationData and self.framework.Data.replicationData.Data and self.framework.Data.replicationData.Data.PortalFirstVisits then
        local firstVisits = self.framework.Data.replicationData.Data.PortalFirstVisits
        
        -- If we have a first visit timestamp, portal is unlocked
        if firstVisits[portalName] ~= nil then
            return false
        end
    end
    
    -- Method 3: Check physical portal (only works if close enough)
    local success, isLocked = pcall(function()
        local portalsFolder = Workspace:FindFirstChild("Zones")
        if not portalsFolder then return nil end
        
        portalsFolder = portalsFolder:FindFirstChild("Portals")
        if not portalsFolder then return nil end
        
        local portalFolder = portalsFolder:FindFirstChild(portalName)
        if not portalFolder then return nil end
        
        local portal = portalFolder:FindFirstChild("Portal")
        if not portal then return nil end
        
        local lockedPortal = portal:FindFirstChild("LockedPortal")
        return lockedPortal ~= nil
    end)
    
    -- If physical check worked, use that
    if success and isLocked ~= nil then
        return isLocked
    end
    
    -- Default: assume locked if we can't verify
    return true
end

function PortalModule:GetCurrentClicks()
    -- Use the unified GetCurrentClicks which tries data first, then UI
    return self.framework:GetModule("GameHelper"):GetCurrentClicks()
end

function PortalModule:CanAffordPortal(portalName)
    if not self.framework.Data.portalsData[portalName] then
        return false, "Portal not found in data"
    end
    
    local portalPrice = self.framework.Data.portalsData[portalName].Price or 0
    local currentClicks = self:GetCurrentClicks()
    
    if currentClicks >= portalPrice then
        return true, portalPrice
    else
        return false, portalPrice
    end
end

function PortalModule:PurchasePortal(portalName)
    -- Check if already unlocked (silently)
    if not self:IsPortalLocked(portalName) then
        return true, "Already unlocked"
    end
    
    -- Check if we can afford it (silently)
    local canAfford, price = self:CanAffordPortal(portalName)
    if not canAfford then
        return false, "Cannot afford (need " .. self.framework:GetModule("Format"):FormatNumber(price) .. " clicks)"
    end
    
    -- Find the BuyPortal remote
    if not self.framework.Remotes.BuyPortal then
        return false, "BuyPortal remote not found"
    end
    
    -- Purchase the portal (silently)
    local success, result = pcall(function()
        return self.framework.Remotes.BuyPortal:InvokeServer(portalName)
    end)
    
    if not success then
        return false, "Purchase failed: " .. tostring(result)
    end
    
    -- Wait a moment for the purchase to register
    task.wait(0.3)
    
    -- Verify it unlocked (silently)
    if not self:IsPortalLocked(portalName) then
        -- Successfully unlocked! Now teleport to it
        if self.framework.Remotes.teleport then
            local teleportSuccess = pcall(function()
                self.framework.Remotes.teleport:InvokeServer(portalName)
            end)
            
            if teleportSuccess then
                return true, "Successfully purchased for " .. self.framework:GetModule("Format"):FormatNumber(price) .. " clicks and teleported"
            else
                return true, "Successfully purchased for " .. self.framework:GetModule("Format"):FormatNumber(price) .. " clicks (teleport failed)"
            end
        else
            return true, "Successfully purchased for " .. self.framework:GetModule("Format"):FormatNumber(price) .. " clicks (no teleport remote)"
        end
    else
        return false, "Purchase completed but portal still locked"
    end
end

function PortalModule:GetBackPortalPosition(portalName)
    local success, position = pcall(function()
        local portalsFolder = Workspace:FindFirstChild("Zones")
        if not portalsFolder then return nil end
        
        portalsFolder = portalsFolder:FindFirstChild("Portals")
        if not portalsFolder then return nil end
        
        local portalFolder = portalsFolder:FindFirstChild(portalName)
        if not portalFolder then return nil end
        
        local backPortal = portalFolder:FindFirstChild("Back")
        if not backPortal then return nil end
        
        if backPortal:IsA("Model") then
            local primaryPart = backPortal.PrimaryPart or backPortal:FindFirstChildWhichIsA("BasePart")
            if primaryPart then
                return primaryPart.CFrame
            end
        elseif backPortal:IsA("BasePart") then
            return backPortal.CFrame
        end
        
        return nil
    end)
    
    return success and position or nil
end

function PortalModule:GetAllLockedPortals()
    local lockedPortals = {}
    
    -- Get all portals from game data
    for portalName, portalInfo in pairs(self.framework.Data.portalsData) do
        if self:IsPortalLocked(portalName) then
            table.insert(lockedPortals, {
                name = portalName,
                multi = portalInfo.Multi or 1,
                price = portalInfo.Price or 0
            })
        end
    end
    
    -- Sort by multiplier (unlock lowest first for progression)
    table.sort(lockedPortals, function(a, b)
        return a.multi < b.multi
    end)
    
    return lockedPortals
end

function PortalModule:UnlockPortal(portalName)
    -- Check unlock mode
    if self.unlockMode == "Purchase" then
        return self:PurchasePortal(portalName)
    end
    
    -- Otherwise use tween mode (default)
    local character = p.Character
    if not character then
        return false, "Character not found"
    end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then
        return false, "HumanoidRootPart not found"
    end
    
    if not self:IsPortalLocked(portalName) then
        return true, "Already unlocked"
    end
    
    local backPortalPos = self:GetBackPortalPosition(portalName)
    if not backPortalPos then
        return false, "Back portal not found"
    end
    
    local success = pcall(function()
        -- Calculate target position 10 studs in front of portal
        local offset = backPortalPos.LookVector * 10 + Vector3.new(0, 5, 0)
        local targetCFrame = backPortalPos + offset
        
        -- Create a fast tween to the portal
        local TweenService = game:GetService("TweenService")
        local tweenInfo = TweenInfo.new(
            0.5, -- Duration: 0.5 seconds (very fast)
            Enum.EasingStyle.Linear, -- Linear movement
            Enum.EasingDirection.InOut,
            0, -- No repeat
            false, -- Don't reverse
            0 -- No delay
        )
        
        local tween = TweenService:Create(hrp, tweenInfo, {CFrame = targetCFrame})
        tween:Play()
        tween.Completed:Wait()
    end)
    
    if not success then
        return false, "Teleport failed"
    end
    
    task.wait(self.framework.Config.portalUnlockDelay)
    
    if not self:IsPortalLocked(portalName) then
        return true, "Successfully unlocked"
    else
        return false, "Still locked after visit"
    end
end

function PortalModule:EnsurePortalUnlocked(portalName)
    if self:IsPortalLocked(portalName) then
        -- Only show notification for tween mode (purchase is instant and less disruptive)
        if self.unlockMode == "Tween" and self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
            self.framework.UI.Library:Notify("üîì Unlocking " .. portalName .. "...", 2)
        end
        
        local success, message = self:UnlockPortal(portalName)
        
        if success then
            -- Only notify on success if enabled
            if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
                self.framework.UI.Library:Notify("‚úì Unlocked " .. portalName .. "!", 2)
            end
            return true
        else
            -- Always notify failures
            if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
                self.framework.UI.Library:Notify("‚úó Failed to unlock " .. portalName .. ": " .. message, 3)
            end
            return false
        end
    end
    
    return true
end

function PortalModule:EnsureAllPortalsUnlocked()
    local lockedPortals = self:GetAllLockedPortals()
    
    if #lockedPortals == 0 then
        return true
    end
    
    local wasAutoUnlockEnabled = self.enabled
    if not wasAutoUnlockEnabled then
        self.enabled = true
        if self.framework.UI.Toggles.AutoUnlockPortals then
            self.framework.UI.Toggles.AutoUnlockPortals:SetValue(true)
        end
        
        if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
            self.framework.UI.Library:Notify("üîì Auto-unlocking " .. #lockedPortals .. " portal(s)...", 3)
        end
    end
    
    local maxWaitTime = 60
    local startTime = tick()
    
    while tick() - startTime < maxWaitTime do
        lockedPortals = self:GetAllLockedPortals()
        
        if #lockedPortals == 0 then
            if not wasAutoUnlockEnabled then
                self.enabled = false
                if self.framework.UI.Toggles.AutoUnlockPortals then
                    self.framework.UI.Toggles.AutoUnlockPortals:SetValue(false)
                end
            end
            
            if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
                self.framework.UI.Library:Notify("‚úì All portals unlocked!", 2)
            end
            return true
        end
        
        task.wait(1)
    end
    
    if not wasAutoUnlockEnabled then
        self.enabled = false
        if self.framework.UI.Toggles.AutoUnlockPortals then
            self.framework.UI.Toggles.AutoUnlockPortals:SetValue(false)
        end
    end
    
    if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
        self.framework.UI.Library:Notify("‚ö† Timeout: " .. #lockedPortals .. " portal(s) still locked", 3)
    end
    return false
end

function PortalModule:StartAutoUnlockLoop()
    task.spawn(function()
        while getgenv().TapSimLoaded do
            task.wait(3)
            if self.enabled then
                local lockedPortals = self:GetAllLockedPortals()
                
                if #lockedPortals > 0 then
                    -- Get current clicks once at the start
                    local currentClicks = self:GetCurrentClicks()
                    
                    for _, portalInfo in ipairs(lockedPortals) do
                        if not self.enabled then break end
                        
                        local portalName = portalInfo.name
                        local portalPrice = portalInfo.price
                        
                        -- Skip if already unlocked (cached)
                        if self.unlockedPortalsCache[portalName] then
                            continue
                        end
                        
                        -- OPTIMIZATION: If in purchase mode and can't afford this portal,
                        -- skip it AND all remaining portals (they're sorted by price)
                        if self.unlockMode == "Purchase" and currentClicks < portalPrice then
                            -- Silently skip - no notifications for unaffordable portals
                            break -- Exit loop entirely since remaining portals are more expensive
                        end
                        
                        -- Only show "unlocking" notification for tween mode
                        if self.unlockMode == "Tween" and self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
                            self.framework.UI.Library:Notify("üîì Unlocking: " .. portalName .. " (" .. portalInfo.multi .. "x)", 1)
                        end
                        
                        local success, message = self:UnlockPortal(portalName)
                        
                        if success then
                            self.unlockedPortalsCache[portalName] = true
                            if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
                                self.framework.UI.Library:Notify("‚úì Unlocked: " .. portalName .. "!", 2)
                            end
                        else
                            -- Only notify failures if it's NOT an affordability issue
                            if not string.find(message, "Cannot afford") then
                                if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
                                    self.framework.UI.Library:Notify("‚úó Failed: " .. portalName .. " - " .. message, 2)
                                end
                            end
                            
                            -- If purchase mode and failed due to affordability, stop trying more expensive portals
                            if self.unlockMode == "Purchase" and string.find(message, "Cannot afford") then
                                break
                            end
                        end
                        
                        task.wait(self.framework.Config.portalUnlockDelay)
                    end
                else
                    self.unlockedPortalsCache = {}
                end
            else
                self.unlockedPortalsCache = {}
            end
        end
    end)
end

function PortalModule:Enable()
    self.enabled = true
    if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
        self.framework.UI.Library:Notify("Auto Unlock Portals enabled - checking every 3s", 3)
    end
    
    task.spawn(function()
        task.wait(1)
        local lockedPortals = self:GetAllLockedPortals()
        if #lockedPortals > 0 then
            if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
                self.framework.UI.Library:Notify("Found " .. #lockedPortals .. " locked portal(s) - unlocking...", 3)
            end
        else
            if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
                self.framework.UI.Library:Notify("All portals are already unlocked!", 2)
            end
        end
    end)
end

function PortalModule:Disable()
    self.enabled = false
    self.unlockedPortalsCache = {}
    if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
        self.framework.UI.Library:Notify("Auto Unlock Portals disabled", 2)
    end
end

Framework:RegisterModule("Portal", PortalModule)

-- Anti-AFK Module (Always Active)
local AntiAFKModule = {
    enabled = true,
    connections = {}
}

function AntiAFKModule:Init(fw)
    self.framework = fw
    self:Start()
end

function AntiAFKModule:Start()
    -- Method 1: Virtual User (Primary)
    local VirtualUser = game:GetService("VirtualUser")
    
    self.connections.idled = p.Idled:Connect(function()
        VirtualUser:CaptureController()
        VirtualUser:ClickButton2(Vector2.new())
    end)
    
    -- Method 2: Periodic input simulation (Backup)
    task.spawn(function()
        while getgenv().TapSimLoaded do
            task.wait(300) -- Every 5 minutes
            
            pcall(function()
                VirtualUser:CaptureController()
                VirtualUser:ClickButton2(Vector2.new())
            end)
        end
    end)
    
    -- Method 3: Character movement micro-adjustments (Tertiary)
    task.spawn(function()
        while getgenv().TapSimLoaded do
            task.wait(240) -- Every 4 minutes
            
            pcall(function()
                local character = p.Character
                if character then
                    local humanoid = character:FindFirstChild("Humanoid")
                    if humanoid and humanoid.Health > 0 then
                        -- Tiny movement that's barely noticeable
                        humanoid:Move(Vector3.new(0.01, 0, 0), false)
                        task.wait(0.1)
                        humanoid:Move(Vector3.new(0, 0, 0), false)
                    end
                end
            end)
        end
    end)
    
    -- Method 4: Keep player connection alive
    task.spawn(function()
        while getgenv().TapSimLoaded do
            task.wait(180) -- Every 3 minutes
            
            pcall(function()
                -- Send a harmless request to keep connection alive
                game:GetService("GuiService"):GetErrorMessage()
            end)
        end
    end)
end

function AntiAFKModule:Stop()
    self.enabled = false
    
    if self.connections.idled then
        self.connections.idled:Disconnect()
        self.connections.idled = nil
    end
end

Framework:RegisterModule("AntiAFK", AntiAFKModule)

-- Teleport Module
local TeleportModule = {
    savedGoldenMachinePosition = nil,
    savedRainbowMachinePosition = nil,
    savedGoldenIslandMultiplier = 0,
    savedRainbowIslandMultiplier = 0
}

function TeleportModule:Init(fw)
    self.framework = fw
end

function TeleportModule:SavePosition()
    local character = p.Character
    if not character then return false end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    
    self.framework.State.savedPosition = hrp.CFrame
    return true
end

function TeleportModule:LoadPosition()
    if not self.framework.State.savedPosition then
        self.framework.UI.Library:Notify("No position saved!", 3)
        return false
    end
    
    local character = p.Character
    if not character then return false end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    
    hrp.CFrame = self.framework.State.savedPosition
    self.framework.UI.Library:Notify("Teleported back to saved position", 2)
    return true
end

function TeleportModule:ClearPosition()
    self.framework.State.savedPosition = nil
    self.framework.UI.Library:Notify("Saved position cleared", 2)
end

function TeleportModule:FindNearestMachine(machineType, maxDistance)
    local character = p.Character
    if not character then return nil, nil end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil, nil end
    
    maxDistance = maxDistance or 1000
    
    local machines = {}
    local searchName = machineType
    
    local function searchContainer(container)
        for _, obj in pairs(container:GetDescendants()) do
            if obj.Name == searchName and obj:IsA("BasePart") then
                local distance = (hrp.Position - obj.Position).Magnitude
                if distance <= maxDistance then
                    table.insert(machines, {
                        model = obj.Parent,
                        part = obj,
                        distance = distance
                    })
                end
            end
        end
    end
    
    for _, child in pairs(Workspace:GetChildren()) do
        if child:IsA("Model") and child.Name ~= "Camera" and child.Name ~= "Terrain" then
            searchContainer(child)
        end
    end
    
    local islandFolder = Workspace:FindFirstChild("Island")
    if islandFolder then
        for _, island in pairs(islandFolder:GetChildren()) do
            if island:IsA("Model") then
                searchContainer(island)
            end
        end
    end
    
    local mapFolder = Workspace:FindFirstChild("Map")
    if mapFolder then
        for _, area in pairs(mapFolder:GetChildren()) do
            if area:IsA("Model") then
                searchContainer(area)
            end
        end
    end
    
    local zonesFolder = Workspace:FindFirstChild("Zones")
    if zonesFolder then
        searchContainer(zonesFolder)
    end
    
    if #machines == 0 then
        return nil, nil
    end
    
    local nearestMachine = nil
    local nearestPart = nil
    local nearestDistance = math.huge
    
    for _, machineData in ipairs(machines) do
        if machineData.distance < nearestDistance then
            nearestDistance = machineData.distance
            nearestMachine = machineData.model
            nearestPart = machineData.part
        end
    end
    
    return nearestPart or nearestMachine, nearestDistance
end

function TeleportModule:IsNearMachine(machineType)
    local character = p.Character
    if not character then return false end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    
    local machine, distance = self:FindNearestMachine(machineType)
    
    if not machine then return false end
    
    return distance <= 20
end

function TeleportModule:IsCraftingGUIOpen(machineType)
    local gui = p.PlayerGui:FindFirstChild("Tabs")
    if not gui then return false end
    
    if machineType == "Golden" then
        local goldenGUI = gui:FindFirstChild("Golden")
        return goldenGUI and goldenGUI.Enabled
    elseif machineType == "Rainbow" then
        local rainbowGUI = gui:FindFirstChild("RainbowCraft")
        return rainbowGUI and rainbowGUI.Enabled
    end
    
    return false
end

function TeleportModule:TeleportToZonesAndFindMachine(machineType)
    if not self.framework.Remotes.teleport then 
        self.framework.UI.Library:Notify("Error: TeleportZone remote not found!", 5)
        return nil, nil
    end
    
    self.framework.UI.Library:Notify("Searching unlocked zones for best " .. machineType .. " machine location...", 3)
    
    local bestMachine = nil
    local bestDistance = math.huge
    local bestMultiplier = 0
    local bestZoneName = nil
    
    -- Build list of zones sorted by multiplier (highest first)
    local sortedZones = {}
    for zoneName, zoneInfo in pairs(self.framework.Data.portalsData) do
        table.insert(sortedZones, {
            name = zoneName,
            multi = zoneInfo.Multi or 1,
            price = zoneInfo.Price or 0
        })
    end
    
    table.sort(sortedZones, function(a, b)
        return a.multi > b.multi
    end)
    
    -- Only search UNLOCKED portals
    for _, zoneInfo in ipairs(sortedZones) do
        local zoneName = zoneInfo.name
        
        -- Skip if portal is locked
        local isLocked = self.framework:GetModule("Portal"):IsPortalLocked(zoneName)
        
        if not isLocked then
            local success = pcall(function()
                self.framework.Remotes.teleport:InvokeServer(zoneName)
            end)
            
            if success then
                task.wait(self.framework.Config.machineSearchDelay)
                
                local machine, distance = self:FindNearestMachine(machineType, 1000)
                
                if machine and distance then
                    local currentMultiplier = self.framework:GetModule("GameHelper"):GetCurrentIslandMultiplier()
                    
                    if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
                        self.framework.UI.Library:Notify("‚úì Found " .. machineType .. " at " .. zoneName .. " (" .. currentMultiplier .. "x, " .. math.floor(distance) .. " studs)", 2)
                    end
                    
                    if currentMultiplier > bestMultiplier then
                        bestMachine = machine
                        bestDistance = distance
                        bestMultiplier = currentMultiplier
                        bestZoneName = zoneName
                        
                        self.framework.UI.Library:Notify("‚úì Best machine found at " .. bestZoneName .. " (" .. bestMultiplier .. "x)!", 2)
                        break
                    end
                else
                    if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
                        self.framework.UI.Library:Notify("No " .. machineType .. " machine at " .. zoneName, 1)
                    end
                end
            end
            
            task.wait(0.1)
        else
            if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
                self.framework.UI.Library:Notify("‚äó Skipping " .. zoneName .. " (locked)", 1)
            end
        end
    end
    
    if bestMachine then
        local character = p.Character
        if character then
            local hrp = character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local targetPos = bestMachine.Position
                local offset = Vector3.new(0, 5, 5)
                local finalPos = CFrame.new(targetPos + offset)
                hrp.CFrame = finalPos
                
                task.wait(0.1)
                
                if machineType == "Golden" then
                    self.framework.State.savedGoldenMachinePosition = finalPos
                    self.framework.State.savedGoldenIslandMultiplier = bestMultiplier
                    self.framework.UI.Library:Notify("‚úì Saved Golden Machine at " .. bestZoneName .. " (" .. bestMultiplier .. "x boost)!", 3)
                elseif machineType == "Rainbow" then
                    self.framework.State.savedRainbowMachinePosition = finalPos
                    self.framework.State.savedRainbowIslandMultiplier = bestMultiplier
                    self.framework.UI.Library:Notify("‚úì Saved Rainbow Machine at " .. bestZoneName .. " (" .. bestMultiplier .. "x boost)!", 3)
                elseif machineType == "Enchant" then
                    self.framework.State.savedEnchantMachinePosition = finalPos
                    self.framework.State.savedEnchantIslandMultiplier = bestMultiplier
                    self.framework.UI.Library:Notify("‚úì Saved Enchant Machine at " .. bestZoneName .. " (" .. bestMultiplier .. "x boost)!", 3)
                end
            end
        end
    else
        self.framework.UI.Library:Notify("‚ö† Could not find " .. machineType .. " machine in any unlocked zone! (Enable 'Auto Unlock Portals' to unlock more)", 5)
    end
    
    return bestMachine, bestDistance
end

function TeleportModule:TeleportToMachine(machineType)
    local character = p.Character
    if not character then return false end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    
    local savedMachinePos = nil
    local savedMultiplier = 0
    
    if machineType == "Golden" and self.framework.State.savedGoldenMachinePosition then
        savedMachinePos = self.framework.State.savedGoldenMachinePosition
        savedMultiplier = self.framework.State.savedGoldenIslandMultiplier
    elseif machineType == "Rainbow" and self.framework.State.savedRainbowMachinePosition then
        savedMachinePos = self.framework.State.savedRainbowMachinePosition
        savedMultiplier = self.framework.State.savedRainbowIslandMultiplier
    elseif machineType == "Enchant" and self.framework.State.savedEnchantMachinePosition then
        savedMachinePos = self.framework.State.savedEnchantMachinePosition
        savedMultiplier = self.framework.State.savedEnchantIslandMultiplier
    end
    
    if savedMachinePos then
        hrp.CFrame = savedMachinePos
        self.framework.UI.Library:Notify("Teleported to saved " .. machineType .. " machine (" .. savedMultiplier .. "x boost)", 2)
        task.wait(0.3)
        return true
    end
    
    self.framework.UI.Library:Notify("No saved " .. machineType .. " machine - searching all zones for best location...", 3)
    
    local machine, distance = self:TeleportToZonesAndFindMachine(machineType)
    
    if not machine then
        self.framework.UI.Library:Notify("Error: Could not find " .. machineType .. " machine in any zone!", 5)
        return false
    end
    
    return true
end

function TeleportModule:EnsureMachineAccess(machineType)
    -- Check if already near machine
    if self:IsNearMachine(machineType) then
        return true
    end
    
    -- Try to teleport to machine
    if not self:TeleportToMachine(machineType) then
        return false
    end
    
    -- Wait a moment and check again
    task.wait(1)
    
    return self:IsNearMachine(machineType)
end

function TeleportModule:ClearSavedLocation(machineType)
    function TeleportModule:ClearSavedLocation(machineType)
    if machineType == "Golden" then
        self.framework.State.savedGoldenMachinePosition = nil
        self.framework.State.savedGoldenIslandMultiplier = 0
        self.framework.UI.Library:Notify("Cleared saved Golden Machine location", 2)
    elseif machineType == "Rainbow" then
        self.framework.State.savedRainbowMachinePosition = nil
        self.framework.State.savedRainbowIslandMultiplier = 0
        self.framework.UI.Library:Notify("Cleared saved Rainbow Machine location", 2)
    elseif machineType == "Enchant" then
        self.framework.State.savedEnchantMachinePosition = nil
        self.framework.State.savedEnchantIslandMultiplier = 0
        self.framework.UI.Library:Notify("Cleared saved Enchant Machine location", 2)
    end
end
end

Framework:RegisterModule("Teleport", TeleportModule)

-- Auto Delete Module
local AutoDeleteModule = {}

function AutoDeleteModule:Init(fw)
    self.framework = fw
end

function AutoDeleteModule:ApplyAutoDelete()
    if not self.framework.Remotes.autoDelete then
        self.framework.UI.Library:Notify("Error: AutoDelete remote not found!", 5)
        return
    end
    
    local count = 0
    for _ in pairs(self.framework.State.selectedDeletePets) do count = count + 1 end
    
    if count == 0 then
        self.framework.UI.Library:Notify("Error: No pets selected!", 5)
        return
    end
    
    local petsArray = {}
    for displayString, _ in pairs(self.framework.State.selectedDeletePets) do
        local petName = string.match(displayString, "^(.-)%s*%[")
        if petName then
            table.insert(petsArray, petName)
        end
    end
    
    local deleteData = {
        [self.framework.State.selectedDeleteEgg] = petsArray
    }
    
    local success = pcall(function()
        self.framework.Remotes.autoDelete:FireServer(deleteData)
    end)
    
    if success then
        self.framework.UI.Library:Notify("Applied auto-delete for " .. count .. " pet(s) from " .. self.framework.State.selectedDeleteEgg, 3)
    else
        self.framework.UI.Library:Notify("Error: Failed to apply auto-delete!", 5)
    end
end

function AutoDeleteModule:ClearAutoDelete()
    if not self.framework.Remotes.autoDelete then
        self.framework.UI.Library:Notify("Error: AutoDelete remote not found!", 5)
        return
    end
    
    local deleteData = {
        [self.framework.State.selectedDeleteEgg] = {}
    }
    
    local success = pcall(function()
        self.framework.Remotes.autoDelete:FireServer(deleteData)
    end)
    
    if success then
        self.framework.UI.Library:Notify("Cleared auto-delete for " .. self.framework.State.selectedDeleteEgg, 3)
    else
        self.framework.UI.Library:Notify("Error: Failed to clear auto-delete!", 5)
    end
end

Framework:RegisterModule("AutoDelete", AutoDeleteModule)

-- Golden Crafting Module
local AutoCraftGoldenModule = {
    enabled = false
}

function AutoCraftGoldenModule:Init(fw)
    self.framework = fw
end

function AutoCraftGoldenModule:Start()
    if self.enabled then return end
    self.enabled = true
    
    if #self.framework.State.selectedGoldenPets == 0 then
        self.framework.UI.Library:Notify("‚ö† No pets selected - waiting for selection or enable Auto Smart Select", 3)
    end
    
    if #self.framework.State.selectedGoldenPets > 0 then
        self.framework.UI.Library:Notify("Auto Craft Golden started for " .. #self.framework.State.selectedGoldenPets .. " pet type(s)", 3)
    else
        self.framework.UI.Library:Notify("Auto Craft Golden enabled - waiting for pets to be selected", 3)
    end
    
    task.spawn(function()
        local successCount = 0
        local failCount = 0
        local currentPetIndex = 1
        local isAtMachine = false
        local hasReturnedToSaved = false
        
        while self.enabled do
            if not self.enabled then break end
            
            -- Wait for crafting lock to be released (Rainbow might be using it)
            while self.framework.State.craftingLock do
                task.wait(0.5)
                if not self.enabled then break end
            end
            
            if not self.enabled then break end
            
            -- If no pets selected, wait and continue
            if #self.framework.State.selectedGoldenPets == 0 then
                task.wait(2)
                continue
            end
            
            -- Calculate net inventory change: crafting uses X pets and gives back 1
            local netInventoryChange = -(self.framework.State.goldenCraftAmount - 1)
            local availableSpace = self.framework:GetModule("GameHelper"):GetAvailableInventorySpace()
            
            -- Only stop if inventory is full AND we can't craft
            local canCraftDespiteFullInventory = (self.framework.State.goldenCraftAmount > 1)
            
            if availableSpace <= 0 and not canCraftDespiteFullInventory then
                if not hasReturnedToSaved then
                    self.framework.UI.Library:Notify("Inventory full and can't craft! Returning to saved position...", 3)
                    self.framework:GetModule("Teleport"):LoadPosition()
                    hasReturnedToSaved = true
                    isAtMachine = false
                end
                task.wait(5)
                continue
            else
                hasReturnedToSaved = false
            end
            
            -- Check if we have any pets left to craft
            local hasPetsLeft = false
            for _, petName in ipairs(self.framework.State.selectedGoldenPets) do
                local petIDs, totalAvailable = self.framework:GetModule("PetManagement"):GetPetIDsForCrafting(petName, self.framework.State.goldenCraftAmount, "Normal")
                if #petIDs >= self.framework.State.goldenCraftAmount then
                    hasPetsLeft = true
                    break
                end
            end
            
            -- If no pets left, return to saved position and wait
            if not hasPetsLeft then
                if not hasReturnedToSaved then
                    self.framework.UI.Library:Notify("No more pets to craft! Returning to saved position...", 3)
                    self.framework:GetModule("Teleport"):LoadPosition()
                    hasReturnedToSaved = true
                    isAtMachine = false
                end
                task.wait(5)
                continue
            end
            
            -- Ensure we have machine access when we have pets
if not isAtMachine or not self.framework:GetModule("Teleport"):IsNearMachine("Golden") then
    if self.framework.UI.Toggles.ShowNotifications.Value then
        self.framework.UI.Library:Notify("Accessing Golden Machine...", 2)
    end
    
    if not self.framework:GetModule("Teleport"):EnsureMachineAccess("Golden") then
        if self.framework.UI.Toggles.ShowNotifications.Value then
            self.framework.UI.Library:Notify("Failed to access Golden Machine - retrying in 5s...", 3)
        end
        task.wait(5)
        continue
    end
    isAtMachine = true
end
            
            -- Cycle through selected pets
            if currentPetIndex > #self.framework.State.selectedGoldenPets then
                currentPetIndex = 1
            end
            
            local currentPet = self.framework.State.selectedGoldenPets[currentPetIndex]
            local petIDs, totalAvailable = self.framework:GetModule("PetManagement"):GetPetIDsForCrafting(currentPet, self.framework.State.goldenCraftAmount, "Normal")
            
            if #petIDs < self.framework.State.goldenCraftAmount then
                currentPetIndex = currentPetIndex + 1
                task.wait(0.5)
            else
                -- Acquire crafting lock
                self.framework.State.craftingLock = true
                
                local success, result = pcall(function()
                    return self.framework.Remotes.craftPets:InvokeServer(petIDs)
                end)
                
                -- Release crafting lock after a short delay
                task.wait(0.5)
                self.framework.State.craftingLock = false
                
                if success and result then
                    if typeof(result) == "table" and result.Tier == "Golden" then
                        successCount = successCount + 1
                        if self.framework.UI.Toggles.ShowNotifications.Value then
                            self.framework.UI.Library:Notify("‚úì Golden " .. currentPet .. " crafted! (" .. successCount .. " total)", 2)
                        end
                    elseif result == "Error" or not result then
                        failCount = failCount + 1
                        if self.framework.UI.Toggles.ShowNotifications.Value then
                            self.framework.UI.Library:Notify("‚úó " .. currentPet .. " craft failed (" .. failCount .. " total)", 2)
                        end
                    end
                else
                    if self.framework.UI.Toggles.ShowNotifications.Value then
                        self.framework.UI.Library:Notify("Craft error - retrying...", 2)
                    end
                end
                
                task.wait(0.5)
            end
            
            -- Invalidate caches after craft attempt
            self.framework:GetModule("Cache"):Invalidate("playerPets_Normal")
            self.framework:GetModule("Cache"):Invalidate("playerPets_Golden")
            self.framework:GetModule("Cache"):Invalidate("ownedPetCounts")
            self.framework:GetModule("Cache"):Invalidate("allGamePets")
            
            -- Check if we still have enough pets of this type
            local checkIDs, checkAvailable = self.framework:GetModule("PetManagement"):GetPetIDsForCrafting(currentPet, self.framework.State.goldenCraftAmount, "Normal")
            if #checkIDs < self.framework.State.goldenCraftAmount then
                currentPetIndex = currentPetIndex + 1
            end
        end
        
        if successCount > 0 or failCount > 0 then
            self.framework.UI.Library:Notify("Golden crafting stopped: " .. successCount .. " success, " .. failCount .. " failed", 5)
        end
    end)
end

function AutoCraftGoldenModule:Stop()
    if not self.enabled then return end
    self.enabled = false
    self.framework.UI.Library:Notify("Auto Craft Golden stopped", 3)
end

Framework:RegisterModule("AutoCraftGolden", AutoCraftGoldenModule)

-- Rainbow Crafting Module
local AutoCraftRainbowModule = {
    enabled = false
}

function AutoCraftRainbowModule:Init(fw)
    self.framework = fw
end

function AutoCraftRainbowModule:Start()
    if self.enabled then return end
    self.enabled = true
    
    if #self.framework.State.selectedRainbowPets == 0 then
        self.framework.UI.Library:Notify("‚ö† No pets selected - waiting for selection or enable Auto Smart Select", 3)
    end
    
    if #self.framework.State.selectedRainbowPets > 0 then
        self.framework.UI.Library:Notify("Auto Craft Rainbow started for " .. #self.framework.State.selectedRainbowPets .. " pet type(s)", 3)
    else
        self.framework.UI.Library:Notify("Auto Craft Rainbow enabled - waiting for pets to be selected", 3)
    end
    
    task.spawn(function()
        local successCount = 0
        local failCount = 0
        local currentPetIndex = 1
        local isAtMachine = false
        local hasReturnedToSaved = false
        
        while self.enabled do
            if not self.enabled then break end
            
            -- Wait for crafting lock to be released (Golden might be using it)
            while self.framework.State.craftingLock do
                task.wait(0.5)
                if not self.enabled then break end
            end
            
            if not self.enabled then break end
            
            -- If no pets selected, wait and continue
            if #self.framework.State.selectedRainbowPets == 0 then
                task.wait(2)
                continue
            end
            
            -- Rainbow crafting ALWAYS frees inventory space since pets go into machine slots
            local canCraftDespiteFullInventory = (self.framework.State.rainbowCraftAmount >= 1)
            
            local availableSpace = self.framework:GetModule("GameHelper"):GetAvailableInventorySpace()
            if availableSpace <= 0 and not canCraftDespiteFullInventory then
                if not hasReturnedToSaved then
                    self.framework.UI.Library:Notify("Inventory full and can't craft! Returning to saved position...", 3)
                    self.framework:GetModule("Teleport"):LoadPosition()
                    hasReturnedToSaved = true
                    isAtMachine = false
                end
                task.wait(5)
                continue
            else
                hasReturnedToSaved = false
            end
            
            -- Check if we have any pets left to craft
            local hasPetsLeft = false
            for _, petName in ipairs(self.framework.State.selectedRainbowPets) do
                local petIDs, totalAvailable = self.framework:GetModule("PetManagement"):GetPetIDsForCrafting(petName, self.framework.State.rainbowCraftAmount, "Golden")
                if #petIDs >= self.framework.State.rainbowCraftAmount then
                    hasPetsLeft = true
                    break
                end
            end
            
            -- If no pets left, return to saved position and wait
            if not hasPetsLeft then
                if not hasReturnedToSaved then
                    self.framework.UI.Library:Notify("No more pets to craft! Returning to saved position...", 3)
                    self.framework:GetModule("Teleport"):LoadPosition()
                    hasReturnedToSaved = true
                    isAtMachine = false
                end
                task.wait(5)
                continue
            end
            
            -- Ensure we have machine access when we have pets
if not isAtMachine or not self.framework:GetModule("Teleport"):IsNearMachine("Rainbow") then
    if self.framework.UI.Toggles.ShowNotifications.Value then
        self.framework.UI.Library:Notify("Accessing Rainbow Machine...", 2)
    end
    
    if not self.framework:GetModule("Teleport"):EnsureMachineAccess("Rainbow") then
        if self.framework.UI.Toggles.ShowNotifications.Value then
            self.framework.UI.Library:Notify("Failed to access Rainbow Machine - retrying in 5s...", 3)
        end
        task.wait(5)
        continue
    end
    isAtMachine = true
end
            
            -- Cycle through selected pets
            if currentPetIndex > #self.framework.State.selectedRainbowPets then
                currentPetIndex = 1
            end
            
            local currentPet = self.framework.State.selectedRainbowPets[currentPetIndex]
            local petIDs, totalAvailable = self.framework:GetModule("PetManagement"):GetPetIDsForCrafting(currentPet, self.framework.State.rainbowCraftAmount, "Golden")
            
            if #petIDs < self.framework.State.rainbowCraftAmount then
                currentPetIndex = currentPetIndex + 1
                task.wait(0.5)
                continue
            else
                -- IMPORTANT: Validate all pets before crafting
                local validPets = {}
                local firstPetName = nil
                local firstPetTier = nil
                
                -- Verify each pet ID exists and is the correct type/tier
                for _, petId in ipairs(petIDs) do
                    if self.framework.Data.replicationData and self.framework.Data.replicationData.Data and self.framework.Data.replicationData.Data.Pets then
                        local petData = self.framework.Data.replicationData.Data.Pets[petId]
                        if petData then
                            -- Check if pet is Golden tier
                            if petData.Tier ~= "Golden" then
                                if self.framework.UI.Toggles.ShowNotifications.Value then
                                    self.framework.UI.Library:Notify("‚ö† Pet " .. petId .. " is not Golden tier (is " .. tostring(petData.Tier) .. ")", 2)
                                end
                                continue
                            end
                            
                            -- Ensure all pets have the same name
                            if not firstPetName then
                                firstPetName = petData.Name
                                firstPetTier = petData.Tier
                            end
                            
                            if petData.Name == firstPetName and petData.Tier == "Golden" then
                                table.insert(validPets, petId)
                            else
                                if self.framework.UI.Toggles.ShowNotifications.Value then
                                    self.framework.UI.Library:Notify("‚ö† Pet mismatch: expected " .. firstPetName .. ", got " .. petData.Name, 2)
                                end
                            end
                        end
                    end
                end
                
                -- Only craft if we have the required amount of valid pets
                if #validPets < self.framework.State.rainbowCraftAmount then
                    if self.framework.UI.Toggles.ShowNotifications.Value then
                        self.framework.UI.Library:Notify("‚ö† Not enough valid golden " .. currentPet .. " (need " .. self.framework.State.rainbowCraftAmount .. ", have " .. #validPets .. ")", 2)
                    end
                    currentPetIndex = currentPetIndex + 1
                    task.wait(0.5)
                    continue
                end
                
                -- Use only the required amount
                local craftIDs = {}
                for i = 1, self.framework.State.rainbowCraftAmount do
                    table.insert(craftIDs, validPets[i])
                end
                
                if self.framework.UI.Toggles.ShowNotifications.Value then
                    self.framework.UI.Library:Notify("Crafting rainbow " .. currentPet .. " with " .. #craftIDs .. " golden pets...", 2)
                end
                
                -- Acquire crafting lock
                self.framework.State.craftingLock = true
                
                local success, result = pcall(function()
                    return self.framework.Remotes.startRainbow:InvokeServer(craftIDs)
                end)
                
                -- Release crafting lock after a short delay
                task.wait(0.5)
                self.framework.State.craftingLock = false
                
                if success then
                    if result then
                        successCount = successCount + 1
                        if self.framework.UI.Toggles.ShowNotifications.Value then
                            self.framework.UI.Library:Notify("‚úì Rainbow " .. currentPet .. " craft started! (" .. successCount .. " total)", 2)
                        end
                    else
                        failCount = failCount + 1
                        if self.framework.UI.Toggles.ShowNotifications.Value then
                            self.framework.UI.Library:Notify("‚úó Craft failed - " .. (result or "unknown error") .. " (" .. failCount .. " total)", 2)
                        end
                    end
                else
                    if self.framework.UI.Toggles.ShowNotifications.Value then
                        self.framework.UI.Library:Notify("Craft error - retrying...", 2)
                    end
                end
                
                task.wait(0.5)
            end
            
            -- Invalidate caches after craft attempt
            self.framework:GetModule("Cache"):Invalidate("playerPets_Golden")
            self.framework:GetModule("Cache"):Invalidate("playerPets_Rainbow")
            self.framework:GetModule("Cache"):Invalidate("ownedPetCounts")
            self.framework:GetModule("Cache"):Invalidate("allGamePets")
            
            -- Check if we still have enough pets
            local checkIDs, checkAvailable = self.framework:GetModule("PetManagement"):GetPetIDsForCrafting(currentPet, self.framework.State.rainbowCraftAmount, "Golden")
            if #checkIDs < self.framework.State.rainbowCraftAmount then
                currentPetIndex = currentPetIndex + 1
            end
        end
        
        if successCount > 0 or failCount > 0 then
            self.framework.UI.Library:Notify("Rainbow crafting stopped: " .. successCount .. " success, " .. failCount .. " failed", 5)
        end
    end)
end

function AutoCraftRainbowModule:Stop()
    if not self.enabled then return end
    self.enabled = false
    self.framework.UI.Library:Notify("Auto Craft Rainbow stopped", 3)
end

Framework:RegisterModule("AutoCraftRainbow", AutoCraftRainbowModule)

-- Auto Claim Rainbow Module
local AutoClaimRainbowModule = {
    enabled = false
}

function AutoClaimRainbowModule:Init(fw)
    self.framework = fw
end

function AutoClaimRainbowModule:Start()
    if self.enabled then return end
    self.enabled = true
    
    task.spawn(function()
        local claimedCount = 0
        
        while self.enabled do
            if not self.enabled then break end
            
            if self.framework.Data.replicationData and self.framework.Data.replicationData.Data and self.framework.Data.replicationData.Data.CraftingPets then
                local rainbowPets = self.framework.Data.replicationData.Data.CraftingPets.Rainbow
                
                if rainbowPets then
                    local serverTime = workspace:GetServerTimeNow()
                    
                    for petId, petData in pairs(rainbowPets) do
                        if not self.enabled then break end
                        
                        local timeLeft = petData.EndTime - serverTime
                        
                        if timeLeft <= 0 then
                            local success, result = pcall(function()
                                return self.framework.Remotes.claimRainbow:InvokeServer(petId)
                            end)
                            
                            if success and result == true then
                                claimedCount = claimedCount + 1
                                if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
                                    self.framework.UI.Library:Notify("‚úì Claimed rainbow " .. petData.Name .. "! (" .. claimedCount .. " total)", 3)
                                end
                            end
                            
                            task.wait(0.5)
                        end
                    end
                end
            end
            
            task.wait(2)
        end
        
        self.framework.UI.Library:Notify("Auto Claim Rainbow stopped - Claimed " .. claimedCount .. " total", 3)
    end)
    
    self.framework.UI.Library:Notify("Auto Claim Rainbow started", 3)
end

function AutoClaimRainbowModule:Stop()
    if not self.enabled then return end
    self.enabled = false
    self.framework.UI.Library:Notify("Auto Claim Rainbow stopped", 3)
end

Framework:RegisterModule("AutoClaimRainbow", AutoClaimRainbowModule)

-- Auto Enchant Module
local AutoEnchantModule = {
    enabled = false
}

function AutoEnchantModule:Init(fw)
    self.framework = fw
end

function AutoEnchantModule:GetEnchantCrystals()
    -- Use the new helper function
    return self.framework:GetModule("GameHelper"):GetEnchantCrystalsFromData()
end

function AutoEnchantModule:FindBestMythicalEgg()
    local bestEgg = nil
    local highestMythicalChance = 0
    
    for eggName, pets in pairs(self.framework.Data.eggPetsData) do
        local mythicalChance = 0
        
        for _, petData in ipairs(pets) do
            if petData.Rarity == "Mythical" or petData.Rarity == "Mythic" then
                mythicalChance = mythicalChance + (petData.Chance or 0)
            end
        end
        
        if mythicalChance > highestMythicalChance then
            -- Also check if we can afford it
            if self.framework:GetModule("GameHelper"):CanAffordEgg(eggName, 1) then
                highestMythicalChance = mythicalChance
                bestEgg = eggName
            end
        end
    end
    
    return bestEgg
end

function AutoEnchantModule:AttemptFarmCrystals()
    if self.framework.State.isCurrentlyFarmingCrystals then
        return -- Already farming
    end
    
    self.framework.State.isCurrentlyFarmingCrystals = true
    
    -- Find best egg for mythical pets if not specified
    if not self.framework.State.crystalFarmEgg then
        local bestEgg = self:FindBestMythicalEgg()
        if bestEgg then
            self.framework.State.crystalFarmEgg = bestEgg
            if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
                self.framework.UI.Library:Notify("üîÆ Auto-selected " .. bestEgg .. " for crystal farming", 3)
            end
        else
            if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
                self.framework.UI.Library:Notify("‚ö† No mythical eggs found! Waiting...", 3)
            end
            self.framework.State.isCurrentlyFarmingCrystals = false
            task.wait(10)
            return
        end
    end
    
    -- Save current auto hatch settings
    local savedAutoHatchEnabled = self.framework.State.autoHatch
    local savedSelectedEgg = self.framework.State.selectedEgg
    local savedHatchAmount = self.framework.State.hatchAmount
    
    -- Save current auto delete settings
    local savedAutoDeleteSelections = {}
    for eggName, selections in pairs(self.framework.State.allDeleteSelections) do
        savedAutoDeleteSelections[eggName] = selections
    end
    
    if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
        self.framework.UI.Library:Notify("üîÆ Taking over Auto Hatch for crystal farming...", 3)
    end
    
    -- Set up auto-delete for crystal farm egg (delete everything except Mythical and above)
    local crystalFarmEggName = self.framework.State.crystalFarmEgg
    local petsToDelete = {}
    
    if self.framework.Data.eggPetsData[crystalFarmEggName] then
        for _, petData in ipairs(self.framework.Data.eggPetsData[crystalFarmEggName]) do
            local rarity = petData.Rarity
            local rarityRank = self.framework:GetModule("GameHelper"):GetRarityRank(rarity)
            local mythicalRank = self.framework:GetModule("GameHelper"):GetRarityRank("Mythical")
            
            -- Delete anything below Mythical rank
            if rarityRank < mythicalRank then
                table.insert(petsToDelete, petData.Name)
            end
        end
    end
    
    -- Apply auto-delete configuration
    if #petsToDelete > 0 then
        local deleteData = {
            [crystalFarmEggName] = petsToDelete
        }
        
        pcall(function()
            self.framework.Remotes.autoDelete:FireServer(deleteData)
        end)
        
        if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
            self.framework.UI.Library:Notify("üîÆ Auto-deleting " .. #petsToDelete .. " pet types (keeping Mythical+)", 2)
        end
    end
    
    -- Override auto hatch settings with crystal farm settings
    self.framework.State.selectedEgg = self.framework.State.crystalFarmEgg
    self.framework.State.hatchAmount = self.framework.State.crystalFarmAmount
    
    -- Enable auto hatch if it wasn't already
    if not savedAutoHatchEnabled then
        self.framework:GetModule("AutoHatch"):Start()
    end
    
    if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
        self.framework.UI.Library:Notify("üîÆ Farming crystals from " .. self.framework.State.crystalFarmEgg .. " (" .. self.framework.State.crystalFarmAmount .. "x hatch)...", 3)
    end
    
    -- Farm until we have enough crystals
    local lastNotification = 0
    while self.framework.State.autoFarmCrystals and self:GetEnchantCrystals() < self.framework.State.minCrystalsThreshold do
        -- Show periodic updates
        local now = tick()
        if now - lastNotification >= 10 then
            local current = self:GetEnchantCrystals()
            local needed = self.framework.State.minCrystalsThreshold
            if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
                self.framework.UI.Library:Notify("üîÆ Crystal farming: " .. current .. "/" .. needed, 2)
            end
            lastNotification = now
        end
        
        task.wait(2)
    end
    
    -- Restore original auto delete settings
    self.framework.State.allDeleteSelections = savedAutoDeleteSelections
    
    -- Re-apply the original auto-delete configuration
    local restoreDeleteData = {}
    for eggName, selections in pairs(savedAutoDeleteSelections) do
        local petsArray = {}
        for displayString, _ in pairs(selections) do
            local petName = string.match(displayString, "^(.-)%s*%[")
            if petName then
                table.insert(petsArray, petName)
            end
        end
        if #petsArray > 0 then
            restoreDeleteData[eggName] = petsArray
        end
    end
    
    -- Clear crystal farm auto-delete and restore original
    pcall(function()
        self.framework.Remotes.autoDelete:FireServer(restoreDeleteData)
    end)
    
    -- Restore original auto hatch settings
    self.framework.State.selectedEgg = savedSelectedEgg
    self.framework.State.hatchAmount = savedHatchAmount
    
    -- Disable auto hatch if it wasn't enabled before
    if not savedAutoHatchEnabled then
        self.framework:GetModule("AutoHatch"):Stop()
    end
    
    if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
        self.framework.UI.Library:Notify("‚úì Crystal farming complete! (" .. self:GetEnchantCrystals() .. " crystals) - Restored original settings", 3)
    end
    
    self.framework.State.isCurrentlyFarmingCrystals = false
end

function AutoEnchantModule:SortPetsByPriority(pets, mode)
    local sorted = {}
    for _, pet in ipairs(pets) do
        table.insert(sorted, pet)
    end
    
    if mode == "Multiplier (Low to High)" then
        table.sort(sorted, function(a, b)
            local multA = self:GetPetMultiplier(a.id)
            local multB = self:GetPetMultiplier(b.id)
            return multA < multB
        end)
    elseif mode == "Multiplier (High to Low)" then
        table.sort(sorted, function(a, b)
            local multA = self:GetPetMultiplier(a.id)
            local multB = self:GetPetMultiplier(b.id)
            return multA > multB
        end)
    elseif mode == "Rarity (Low to High)" then
        table.sort(sorted, function(a, b)
            local rarityA = self:GetPetRarityRank(a.id)
            local rarityB = self:GetPetRarityRank(b.id)
            return rarityA < rarityB
        end)
    elseif mode == "Rarity (High to Low)" then
        table.sort(sorted, function(a, b)
            local rarityA = self:GetPetRarityRank(a.id)
            local rarityB = self:GetPetRarityRank(b.id)
            return rarityA > rarityB
        end)
    end
    
    return sorted
end

function AutoEnchantModule:GetPetMultiplier(petId)
    local success, mult = pcall(function()
        if self.framework.Data.replicationData and self.framework.Data.replicationData.Data and self.framework.Data.replicationData.Data.Pets then
            local petData = self.framework.Data.replicationData.Data.Pets[petId]
            if petData then
                return petData.Multiplier1 or petData.Multi1 or 0
            end
        end
        return 0
    end)
    return success and mult or 0
end

function AutoEnchantModule:GetPetRarityRank(petId)
    local success, rank = pcall(function()
        if self.framework.Data.replicationData and self.framework.Data.replicationData.Data and self.framework.Data.replicationData.Data.Pets then
            local petData = self.framework.Data.replicationData.Data.Pets[petId]
            if petData and petData.Name then
                local petStats = self.framework.Data.petStats[petData.Name]
                if petStats and petStats.Rarity then
                    return self.framework:GetModule("GameHelper"):GetRarityRank(petStats.Rarity)
                end
            end
        end
        return 0
    end)
    return success and rank or 0
end

function AutoEnchantModule:AttemptFarmCrystals()
    if self.framework.State.isCurrentlyFarmingCrystals then
        return -- Already farming
    end
    
    self.framework.State.isCurrentlyFarmingCrystals = true
    
    -- Find best egg for mythical pets
    if not self.framework.State.crystalFarmEgg then
        local bestEgg = self:FindBestMythicalEgg()
        if bestEgg then
            self.framework.State.crystalFarmEgg = bestEgg
            if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
                self.framework.UI.Library:Notify("üîÆ Auto-selected " .. bestEgg .. " for crystal farming", 3)
            end
        else
            if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
                self.framework.UI.Library:Notify("‚ö† No mythical eggs found! Waiting...", 3)
            end
            self.framework.State.isCurrentlyFarmingCrystals = false
            task.wait(10)
            return
        end
    end
    
    -- Save current position
    self.framework:GetModule("Teleport"):SavePosition()
    
    -- Enable auto hatch temporarily
    local wasAutoHatchEnabled = self.framework.State.autoHatch
    local originalEgg = self.framework.State.selectedEgg
    local originalAmount = self.framework.State.hatchAmount
    
    -- Set to crystal farm egg
    self.framework.State.selectedEgg = self.framework.State.crystalFarmEgg
    self.framework.State.hatchAmount = self.framework.State.crystalFarmAmount
    
    if not wasAutoHatchEnabled then
        self.framework:GetModule("AutoHatch"):Start()
    end
    
    if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
        self.framework.UI.Library:Notify("üîÆ Farming crystals from " .. self.framework.State.crystalFarmEgg .. "...", 3)
    end
    
    -- Farm until we have enough crystals
    while self.framework.State.autoFarmCrystals and self:GetEnchantCrystals() < self.framework.State.minCrystalsThreshold do
        task.wait(2)
    end
    
    -- Restore original settings
    self.framework.State.selectedEgg = originalEgg
    self.framework.State.hatchAmount = originalAmount
    
    if not wasAutoHatchEnabled then
        self.framework:GetModule("AutoHatch"):Stop()
    end
    
    -- Return to saved position
    self.framework:GetModule("Teleport"):LoadPosition()
    
    if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
        self.framework.UI.Library:Notify("‚úì Crystal farming complete! (" .. self:GetEnchantCrystals() .. " crystals)", 3)
    end
    
    self.framework.State.isCurrentlyFarmingCrystals = false
end

function AutoEnchantModule:FindBestMythicalEgg()
    local bestEgg = nil
    local highestMythicalChance = 0
    
    for eggName, pets in pairs(self.framework.Data.eggPetsData) do
        local mythicalChance = 0
        
        for _, petData in ipairs(pets) do
            if petData.Rarity == "Mythical" or petData.Rarity == "Mythic" then
                mythicalChance = mythicalChance + (petData.Chance or 0)
            end
        end
        
        if mythicalChance > highestMythicalChance then
            -- Also check if we can afford it
            if self.framework:GetModule("GameHelper"):CanAffordEgg(eggName, 1) then
                highestMythicalChance = mythicalChance
                bestEgg = eggName
            end
        end
    end
    
    return bestEgg
end

function AutoEnchantModule:GetEnchantCrystals()
    local success, count = pcall(function()
        if self.framework.Data.replicationData and self.framework.Data.replicationData.Data and self.framework.Data.replicationData.Data.Items then
            return self.framework.Data.replicationData.Data.Items.EnchantCrystal or 0
        end
        return 0
    end)
    return success and count or 0
end

function AutoEnchantModule:GetSelectedPetInMachine()
    local success, petId = pcall(function()
        -- Check what pet is selected in the enchant UI
        local enchantUI = p.PlayerGui.Tabs.Enchant.Menu.Inner.Main
        if not enchantUI then return nil end
        
        local petSlot = enchantUI.PetSlot
        if not petSlot then return nil end
        
        -- Check if a pet is selected (Add button not visible means pet is selected)
        if petSlot.Add.Visible then
            return nil -- No pet selected
        end
        
        -- Pet is selected, need to find which one
        -- We'll track this through the module's state
        return self.framework.State.selectedEnchantPet
    end)
    
    return success and petId or nil
end

function AutoEnchantModule:GetCurrentEnchant(petId)
    if not petId then return nil end
    
    local maxRetries = 3
    local retryDelay = 0.1
    
    for attempt = 1, maxRetries do
        local success, enchant = pcall(function()
            -- Force fresh read from replication data
            if self.framework.Data.replicationData and 
               self.framework.Data.replicationData.Data and 
               self.framework.Data.replicationData.Data.Pets then
                
                local petData = self.framework.Data.replicationData.Data.Pets[petId]
                if petData then
                    -- Try multiple possible field names (case-insensitive search)
                    local possibleFields = {
                        "Enchant", "enchant", "ENCHANT",
                        "Enchantment", "enchantment",
                        "EnchantType", "enchantType",
                        "CurrentEnchant", "currentEnchant"
                    }
                    
                    for _, fieldName in ipairs(possibleFields) do
                        if petData[fieldName] and petData[fieldName] ~= "" then
                            return petData[fieldName]
                        end
                    end
                    
                    -- If no field found, pet might not be enchanted yet
                    return nil
                end
            end
            
            return nil
        end)
        
        if success and enchant and enchant ~= "" then
            return enchant
        end
        
        -- If first attempt failed, wait and try again
        if attempt < maxRetries then
            task.wait(retryDelay)
        end
    end
    
    return nil
end

function AutoEnchantModule:SelectPetForEnchant(petId)
    -- No UI needed - just set the active pet ID
    self.framework.State.selectedEnchantPet = petId
    return true
end

function AutoEnchantModule:SpinEnchant()
    if not self.framework.Remotes.enchantPet then
        return false, "Enchant remote not found"
    end
    
    local petId = self.framework.State.selectedEnchantPet
    if not petId then
        return false, "No pet selected"
    end
    
    -- FIRST CALL: Returns current enchant + queues a new roll
    local success1, result1 = pcall(function()
        return self.framework.Remotes.enchantPet:InvokeServer(petId)
    end)
    
    if not success1 then
        return false, "Remote call failed: " .. tostring(result1)
    end
    
    -- Check if we have crystals
    if result1 == false or result1 == nil then
        return false, "No crystals"
    end
    
    -- Parse what we currently have (this is the OLD enchant)
    local oldEnchant = nil
    if type(result1) == "table" and #result1 >= 2 then
        oldEnchant = result1[2]  -- {true, "EnchantName"}
    elseif type(result1) == "string" then
        oldEnchant = result1
    end
    
    -- Wait for the queue to process
    task.wait(0.3)
    
    -- SECOND CALL: Applies the queued roll + queues another
    local success2, result2 = pcall(function()
        return self.framework.Remotes.enchantPet:InvokeServer(petId)
    end)
    
    if not success2 then
        return false, "Second call failed: " .. tostring(result2)
    end
    
    if result2 == false or result2 == nil then
        return false, "No crystals for second call"
    end
    
    -- The enchant that was just applied is the one queued from the first call
    -- We need to read it from replication data since result2 shows the NEXT one
    task.wait(0.3)
    
    local actualEnchant = self:GetCurrentEnchant(petId)
    
    if not actualEnchant then
        return false, "Could not read enchant from replication data"
    end
    
    if actualEnchant == oldEnchant then
        return false, "Enchant didn't change (still: " .. tostring(oldEnchant) .. ")"
    end
    
    self.framework.State.enchantFailStreak = 0
    self.framework.State.lastEnchantResult = actualEnchant
    
    return true, actualEnchant
end

function AutoEnchantModule:InitializePetForEnchanting(petId)
    -- When we first start enchanting a pet, we need to "flush" the current enchant
    -- The first call returns what it CURRENTLY has, the second applies the NEW enchant
    
    if not self.framework.Remotes.enchantPet then
        return false, "Enchant remote not found"
    end
    
    -- Check current enchant
    local currentEnchant = self:GetCurrentEnchant(petId)
    
    -- First call: Get current + queue new
    local success1, result1 = pcall(function()
        return self.framework.Remotes.enchantPet:InvokeServer(petId)
    end)
    
    if not success1 or result1 == false or result1 == nil then
        return false, "No crystals for initialization"
    end
    
    task.wait(0.2)
    
    -- Second call: Apply queued + queue another
    local success2, result2 = pcall(function()
        return self.framework.Remotes.enchantPet:InvokeServer(petId)
    end)
    
    if not success2 or result2 == false or result2 == nil then
        -- First enchant was applied but we're out of crystals
        task.wait(0.3)
        local newEnchant = self:GetCurrentEnchant(petId)
        return true, newEnchant
    end
    
    -- Now we're synchronized - the pet has been enchanted once
    task.wait(0.3)
    local newEnchant = self:GetCurrentEnchant(petId)
    
    return true, newEnchant
end

-- Helper function to extract enchant base name and tier
local function parseEnchantName(enchantName)
    if not enchantName or type(enchantName) ~= "string" then 
        return nil, 0, nil
    end
    
    -- Trim whitespace
    enchantName = string.gsub(enchantName, "^%s+", "")
    enchantName = string.gsub(enchantName, "%s+$", "")
    
    -- Match patterns like "Taps I", "Taps II", etc.
    local baseName, romanNumeral = string.match(enchantName, "^(.-)%s+([IVX]+)$")
    
    if baseName and romanNumeral then
        -- Convert roman numeral to number
        local romanValues = {I = 1, V = 5, X = 10}
        local tier = 0
        local prevValue = 0
        
        for i = #romanNumeral, 1, -1 do
            local char = string.sub(romanNumeral, i, i)
            local value = romanValues[char] or 0
            
            if value < prevValue then
                tier = tier - value
            else
                tier = tier + value
            end
            prevValue = value
        end
        
        return baseName, tier, "tiered"
    else
        -- No tier - check if it's a special enchant
        local enchantType = nil
        
        if string.find(string.lower(enchantName), "golden") then
            enchantType = "golden"
        elseif string.find(string.lower(enchantName), "rainbow") then
            enchantType = "rainbow"
        elseif string.find(string.lower(enchantName), "secret") then
            enchantType = "secret"
        end
        
        return enchantName, 0, enchantType
    end
end

-- Helper function to get special enchant rank (higher = better)
local function getSpecialEnchantRank(enchantType)
    local ranks = {
        ["golden"] = 1,
        ["rainbow"] = 2,
        ["secret"] = 3
    }
    return ranks[enchantType] or 0
end

-- Helper function to check if new enchant is better than current
local function isEnchantBetter(currentEnchant, newEnchant, targetEnchants)
    local currentBase, currentTier, currentType = parseEnchantName(currentEnchant)
    local newBase, newTier, newType = parseEnchantName(newEnchant)
    
    -- Extract base names without special prefixes for comparison
    local currentCoreName = string.gsub(currentBase or "", "^Golden%s*", "")
    currentCoreName = string.gsub(currentCoreName, "^Rainbow%s*", "")
    currentCoreName = string.gsub(currentCoreName, "^Secret%s*", "")
    
    local newCoreName = string.gsub(newBase or "", "^Golden%s*", "")
    newCoreName = string.gsub(newCoreName, "^Rainbow%s*", "")
    newCoreName = string.gsub(newCoreName, "^Secret%s*", "")
    
    -- If completely different enchant families, check if new one is a target
    if currentCoreName ~= newCoreName then
        for targetEnchant, _ in pairs(targetEnchants) do
            local cleanTarget = string.match(targetEnchant, "^(.-)%s*%(") or targetEnchant
            local targetBase, targetTier, targetType = parseEnchantName(cleanTarget)
            
            local targetCoreName = string.gsub(targetBase or "", "^Golden%s*", "")
            targetCoreName = string.gsub(targetCoreName, "^Rainbow%s*", "")
            targetCoreName = string.gsub(targetCoreName, "^Secret%s*", "")
            
            if newCoreName == targetCoreName then
                return true -- New enchant matches a target
            end
        end
        return false
    end
    
    -- Same family - compare based on type
    if currentType and newType then
        -- Both are special enchants (golden/rainbow/secret)
        local currentRank = getSpecialEnchantRank(currentType)
        local newRank = getSpecialEnchantRank(newType)
        
        -- New enchant is better if it has a higher rank
        return newRank > currentRank
    elseif not currentType and not newType then
        -- Both are tiered enchants (same base name)
        return newTier > currentTier
    elseif newType then
        -- New is special, current is tiered - special is always better
        return true
    else
        -- Current is special, new is tiered - keep current
        return false
    end
end

function AutoEnchantModule:Start()
    if self.enabled then return end
    self.enabled = true
    
    local enchantCount = 0
    for _ in pairs(self.framework.State.selectedEnchantTypes) do enchantCount = enchantCount + 1 end
    
    if enchantCount == 0 or #self.framework.State.selectedEnchantPets == 0 then
        local msg = enchantCount == 0 and "No enchants selected" or "No pets selected"
        self.framework.UI.Library:Notify("‚ö† " .. msg .. " - Auto Enchant disabled", 3)
        self.enabled = false
        if self.framework.UI.Toggles.AutoEnchant then
            self.framework.UI.Toggles.AutoEnchant:SetValue(false)
        end
        return
    end
    
    -- Helper: Parse enchant name into base and tier
    local function parseEnchantName(enchantName)
        if not enchantName or type(enchantName) ~= "string" then return nil, 0 end
        
        enchantName = string.gsub(enchantName, "^%s+", "")
        enchantName = string.gsub(enchantName, "%s+$", "")
        
        local baseName, romanNumeral = string.match(enchantName, "^(.-)%s+([IVXLCDM]+)$")
        
        if baseName and romanNumeral then
            local romanValues = {I=1, V=5, X=10, L=50, C=100}
            local tier = 0
            local i = 1
            
            while i <= #romanNumeral do
                local char = string.sub(romanNumeral, i, i)
                local value = romanValues[char] or 0
                local nextChar = string.sub(romanNumeral, i + 1, i + 1)
                local nextValue = romanValues[nextChar] or 0
                
                if nextValue > value then
                    tier = tier + nextValue - value
                    i = i + 2
                else
                    tier = tier + value
                    i = i + 1
                end
            end
            
            return baseName, tier
        end
        
        return enchantName, 0
    end
    
    local function cleanEnchantName(displayString)
        if not displayString then return "" end
        local parts = string.split(displayString, "(")
        local clean = parts[1] or displayString
        return string.gsub(clean, "%s+$", "")
    end
    
    local enchantNames = {}
    for enchantName, _ in pairs(self.framework.State.selectedEnchantTypes) do
        local cleaned = cleanEnchantName(enchantName)
        if cleaned and cleaned ~= "" then
            table.insert(enchantNames, cleaned)
        end
    end
    
    self.framework.UI.Library:Notify("üîÆ Auto Enchant started - " .. #self.framework.State.selectedEnchantPets .. " pet(s), targeting: " .. table.concat(enchantNames, ", "), 3)
    
    task.spawn(function()
        local totalSpins = 0
        local failCount = 0
        local petQueue = {}
        local completedPets = {}
        
        -- Initialize queue tracking for UI
        self.framework.State.enchantQueueSize = #self.framework.State.selectedEnchantPets
        self.framework.State.enchantQueueCompleted = 0
        self.framework.State.enchantTotalSpins = 0
        self.framework.State.enchantQueue = {}
        
        -- Build initial queue
        for _, petData in ipairs(self.framework.State.selectedEnchantPets) do
            table.insert(petQueue, {
                id = petData.id,
                name = petData.name,
                completed = false
            })
        end
        
        -- Main enchanting loop - continues until disabled
        while self.enabled do
            if not self.enabled then break end
            
            -- Check crystals globally before processing queue
            local crystals = self:GetEnchantCrystals()
            if crystals < 1 then
                if self.framework.State.autoFarmCrystals and crystals < self.framework.State.minCrystalsThreshold then
                    if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
                        self.framework.UI.Library:Notify("üîÆ Low crystals - farming...", 2)
                    end
                    self:AttemptFarmCrystals()
                else
                    if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
                        self.framework.UI.Library:Notify("‚ö† Out of crystals - waiting...", 2)
                    end
                    task.wait(5)
                    continue
                end
            end
            
            -- Process each pet in queue
local allPetsCompleted = true

for i, pet in ipairs(petQueue) do
    if not self.enabled then break end
    
    if pet.completed then
        continue
    end
    
    -- At least one pet is not completed
    allPetsCompleted = false
    
    -- Set as active pet
    self.framework.State.selectedEnchantPet = pet.id
    
    -- FORCE FRESH READ of current enchant (with retry logic)
    local currentEnchant = nil
    for retry = 1, 3 do
        currentEnchant = self:GetCurrentEnchant(pet.id)
        if currentEnchant or retry == 3 then break end
        task.wait(0.2)
    end
    
    if currentEnchant then
        local currentBase, currentTier = parseEnchantName(currentEnchant)
        
        local alreadyHasTarget = false
        for selectedEnchant, _ in pairs(self.framework.State.selectedEnchantTypes) do
            local targetClean = cleanEnchantName(selectedEnchant)
            local targetBase, targetTier = parseEnchantName(targetClean)
            
            if currentBase and targetBase and 
               string.lower(currentBase) == string.lower(targetBase) and 
               currentTier >= targetTier then
                alreadyHasTarget = true
                break
            end
        end
        
        if alreadyHasTarget then
            -- Pet already has target, mark complete and skip
            pet.completed = true
            table.insert(completedPets, pet.name)
            if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
                self.framework.UI.Library:Notify("‚úì " .. pet.name .. " already has: " .. currentEnchant, 2)
            end
            continue
        end
    end
             
                -- Check crystals before each spin
crystals = self:GetEnchantCrystals()
if crystals < 1 then
    if self.framework.State.autoFarmCrystals and crystals < self.framework.State.minCrystalsThreshold then
        if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
            self.framework.UI.Library:Notify("üîÆ Low crystals - farming...", 2)
        end
        self:AttemptFarmCrystals()
    else
        task.wait(5)
        break
    end
end

-- Spin the enchant
local spinSuccess, enchantResult = self:SpinEnchant()

if spinSuccess then
    totalSpins = totalSpins + 1
    self.framework.State.enchantTotalSpins = totalSpins
    
    if enchantResult and enchantResult ~= "" and enchantResult ~= "Unknown" then
        local gotBase, gotTier = parseEnchantName(enchantResult)
        
        -- Check if this matches our target
        local foundMatch = false
        for selectedEnchant, _ in pairs(self.framework.State.selectedEnchantTypes) do
            local targetClean = cleanEnchantName(selectedEnchant)
            local targetBase, targetTier = parseEnchantName(targetClean)
            
            if gotBase and targetBase and 
               string.lower(gotBase) == string.lower(targetBase) and 
               gotTier >= targetTier then
                
                pet.completed = true
                table.insert(completedPets, pet.name)
                foundMatch = true
                if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
                    self.framework.UI.Library:Notify("‚úì‚úì " .. pet.name .. " got " .. enchantResult .. "!", 3)
                end
                break
            end
        end
        
        -- Show what we got if it wasn't a match
        if not foundMatch then
            if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
                self.framework.UI.Library:Notify("‚Üí " .. pet.name .. " got " .. enchantResult .. " (re-rolling)", 1)
            end
        end
        
        -- Small delay between spins
        task.wait(0.5)
    else
        if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
            self.framework.UI.Library:Notify("‚ö† Spin returned no enchant", 2)
        end
        task.wait(2)
    end
else
    -- Spin failed
    failCount = failCount + 1
    if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
        self.framework.UI.Library:Notify("‚ö† Spin failed: " .. tostring(enchantResult), 2)
    end
    task.wait(2)
end

-- Now do regular spinning
local spinSuccess, enchantResult = self:SpinEnchant()
                
                if spinSuccess then
                    totalSpins = totalSpins + 1
                    self.framework.State.enchantTotalSpins = totalSpins
                    
                    -- First spin only gives us a prediction, not actual result
                    if totalSpins == 1 then
                        if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
                            self.framework.UI.Library:Notify("‚Üí First spin for " .. pet.name .. " (next will be: " .. enchantResult .. ")", 1)
                        end
                        task.wait(0.5)
                        continue  -- Go to next iteration to get actual result
                    end
                    
                    -- enchantResult is the ACTUAL enchant that was applied (from previous prediction)
                    if enchantResult and enchantResult ~= "" and enchantResult ~= "Unknown" then
                        local gotBase, gotTier = parseEnchantName(enchantResult)
                        
                        -- Check if this matches our target
                        local foundMatch = false
                        for selectedEnchant, _ in pairs(self.framework.State.selectedEnchantTypes) do
                            local targetClean = cleanEnchantName(selectedEnchant)
                            local targetBase, targetTier = parseEnchantName(targetClean)
                            
                            if gotBase and targetBase and 
                               string.lower(gotBase) == string.lower(targetBase) and 
                               gotTier >= targetTier then
                                
                                pet.completed = true
                                table.insert(completedPets, pet.name)
                                foundMatch = true
                                if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
                                    self.framework.UI.Library:Notify("‚úì‚úì " .. pet.name .. " got " .. enchantResult .. "!", 3)
                                end
                                break
                            end
                        end
                        
                        -- Show what we got if it wasn't a match
                        if not foundMatch then
                            if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
                                self.framework.UI.Library:Notify("‚Üí " .. pet.name .. " got " .. enchantResult .. " (re-rolling)", 1)
                            end
                        end
                        
                        -- Small delay between spins
                        task.wait(0.5)
                    else
                        if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
                            self.framework.UI.Library:Notify("‚ö† Spin returned no enchant", 2)
                        end
                        task.wait(2)
                    end
                else
                    -- Spin failed
                    failCount = failCount + 1
                    if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
                        self.framework.UI.Library:Notify("‚ö† Spin failed: " .. tostring(enchantResult), 2)
                    end
                    task.wait(2)
                end
                
                -- Update queue info for UI
                local remaining = 0
                for _, qPet in ipairs(petQueue) do
                    if not qPet.completed then
                        remaining = remaining + 1
                    end
                end
                
                self.framework.State.enchantQueueSize = remaining
                self.framework.State.enchantQueueCompleted = #completedPets
                self.framework.State.enchantQueue = petQueue
                
                -- Don't hog CPU
                task.wait(0.1)
            end
            
            -- If all pets are completed, exit the loop
            if allPetsCompleted then
                self.framework.UI.Library:Notify("üéâ Auto Enchant complete - All " .. #completedPets .. " pets enchanted! (" .. totalSpins .. " total spins)", 5)
                self.enabled = false
                if self.framework.UI.Toggles.AutoEnchant then
                    self.framework.UI.Toggles.AutoEnchant:SetValue(false)
                end
                break
            end
            
            -- Small delay before next loop iteration
            task.wait(0.1)
        end
        
        -- Cleanup when stopped manually
        if not allPetsCompleted and not self.enabled then
            self.framework.UI.Library:Notify("Auto Enchant stopped - Completed " .. #completedPets .. "/" .. #petQueue .. " pets (" .. totalSpins .. " spins)", 3)
        end
    end)
end

function AutoEnchantModule:Stop()
    if not self.enabled then return end
    self.enabled = false
    
    -- If we were farming crystals, stop and restore settings
    if self.framework.State.isCurrentlyFarmingCrystals then
        self.framework.State.autoFarmCrystals = false
        self.framework.State.isCurrentlyFarmingCrystals = false
    end
    
    self.framework.UI.Library:Notify("Auto Enchant stopped", 3)
end

Framework:RegisterModule("AutoEnchant", AutoEnchantModule)

print("‚úì Pet management and crafting modules loaded")
print("‚úì Loading feature modules...")

-- Feature Modules

-- Auto Tap Module
local AutoTapModule = {
    enabled = false,
    tapRate = 0.001,
    lastTap = 0,
    connection = nil
}

function AutoTapModule:Init(fw)
    self.framework = fw
end

function AutoTapModule:Start()
    if self.enabled then return end
    self.enabled = true
    
    self.connection = RunService.Heartbeat:Connect(function()
        if not self.enabled then return end
        
        local now = tick()
        if now - self.lastTap >= self.tapRate then
            pcall(function()
                self.framework.Remotes.tap:FireServer(true, nil, false)
            end)
            self.lastTap = now
        end
    end)
    
    self.framework:AddConnection("AutoTap", self.connection)
    self.framework.UI.Library:Notify("Auto Tap started", 3)
end

function AutoTapModule:Stop()
    if not self.enabled then return end
    self.enabled = false
    
    self.framework:RemoveConnection("AutoTap")
    self.connection = nil
    self.framework.UI.Library:Notify("Auto Tap stopped", 3)
end

Framework:RegisterModule("AutoTap", AutoTapModule)

-- Auto Rebirth Module
local AutoRebirthModule = {
    enabled = false,
    connection = nil
}

function AutoRebirthModule:Init(fw)
    self.framework = fw
end

function AutoRebirthModule:GetRebirthList()
    local success, result = pcall(function()
        return p.PlayerGui.RightHud.Main.RightUI.Rebirths.List
    end)
    return success and result or nil
end

function AutoRebirthModule:GetHighestUnlockedRebirthButton()
    local rebirthListUI = self:GetRebirthList()
    if not rebirthListUI then return nil end
    
    local highestNumber = 0
    for _, child in pairs(rebirthListUI:GetChildren()) do
        if child:IsA("Frame") or child:IsA("GuiObject") then
            local rebirthNum = tonumber(child.Name)
            if rebirthNum and rebirthNum > highestNumber then
                highestNumber = rebirthNum
            end
        end
    end
    
    return highestNumber > 0 and highestNumber or nil
end

function AutoRebirthModule:CanAffordRebirth(buttonIndex)
    local rebirthListUI = self:GetRebirthList()
    if not rebirthListUI then return false end
    
    local buttonFrame = rebirthListUI:FindFirstChild(tostring(buttonIndex))
    if not buttonFrame then return false end
    
    local template = buttonFrame:FindFirstChild("Template")
    if not template then return false end
    
    local main = template:FindFirstChild("Main")
    if not main then return false end
    
    local canBuy = main:FindFirstChild("CanBuy")
    if not canBuy or not canBuy:IsA("UIGradient") then return false end
    
    return canBuy.Enabled
end

function AutoRebirthModule:Start()
    if self.enabled then return end
    self.enabled = true
    
    -- Cancel any existing task first
    self.framework:RemoveTask("AutoRebirth")
    
    -- Create new task
    local rebirthTask = task.spawn(function()
        while self.enabled and getgenv().TapSimLoaded do
            local buttonIndex = nil
            
            if self.framework.State.selectedRebirthButton == "Max" then
                buttonIndex = self:GetHighestUnlockedRebirthButton()
            else
                buttonIndex = self.framework.State.selectedRebirthButton
            end
            
            if buttonIndex and self:CanAffordRebirth(buttonIndex) then
                pcall(function()
                    self.framework.Remotes.rebirth:InvokeServer(buttonIndex)
                end)
            end
            
            task.wait(self.framework.State.rebirthDelay > 0 and self.framework.State.rebirthDelay or 0.1)
        end
    end)
    
    -- Track the task properly
    self.framework:AddTask("AutoRebirth", rebirthTask)
    
    self.framework.UI.Library:Notify("Auto Rebirth started", 3)
end

function AutoRebirthModule:Stop()
    if not self.enabled then return end
    self.enabled = false
    
    -- Cancel the task
    self.framework:RemoveTask("AutoRebirth")
    
    self.framework.UI.Library:Notify("Auto Rebirth stopped", 3)
end

Framework:RegisterModule("AutoRebirth", AutoRebirthModule)

-- Auto Hatch Module
local AutoHatchModule = {
    enabled = false,
    connections = {}
}

function AutoHatchModule:Init(fw)
    self.framework = fw
end

function AutoHatchModule:Start()
    if self.enabled then return end
    
    -- One-time inventory load check (only runs if inventory was never opened)
    if not self.framework:GetModule("InventoryLoader"):EnsureInventoryLoaded() then
        self.framework.UI.Library:Notify("‚ö† Failed to load inventory data - please open inventory manually", 5)
        return
    end
    
    self.enabled = true
    
    self.framework.Stats.eggStats.isTracking = true
    self.framework.Stats.eggStats.startTime = tick()
    self.framework.Stats.eggStats.lastUpdateTime = tick()
    
    -- ... rest of the function remains the same
    
    local monitorTask = task.spawn(function()
        local leaderstats = p:FindFirstChild("leaderstats")
        if not leaderstats then return end
        
        local eggsValue = leaderstats:FindFirstChild("Eggs")
        if not eggsValue then return end
        
        local lastEggCount = eggsValue.Value
        
        while self.enabled and getgenv().TapSimLoaded do
            task.wait(0.1)
            
            local currentEggCount = eggsValue.Value
            if currentEggCount > lastEggCount then
                local eggsHatched = currentEggCount - lastEggCount
                
                self.framework.Stats.eggStats.totalHatched = self.framework.Stats.eggStats.totalHatched + eggsHatched
                
                local eggCost = 0
                local eggForCost = self.framework.State.selectedEgg
                
                if self.framework.State.selectedEgg == "Best Affordable Egg" then
                    local bestEgg, bestPrice = self.framework:GetModule("GameHelper"):GetBestAffordableEgg()
                    if bestEgg then
                        eggForCost = bestEgg
                    end
                end
                
                if self.framework.Data.eggData[eggForCost] then
                    eggCost = self.framework.Data.eggData[eggForCost].Price
                end
                
                local clicksSpent = eggCost * eggsHatched
                self.framework.Stats.eggStats.totalClicksSpent = self.framework.Stats.eggStats.totalClicksSpent + clicksSpent
                
                lastEggCount = currentEggCount
            end
        end
    end)
    
    self.framework:AddTask("AutoHatchMonitor", monitorTask)
    
    local hatchTask = task.spawn(function()
        local originalHatchAmount = self.framework.State.hatchAmount
        local hasWarnedFull = false
        local lastNotifiedAmount = originalHatchAmount
        local lastAffordableAmount = originalHatchAmount
        
        while self.enabled do
            if not self.enabled then break end
            
            local availableSpace = self.framework:GetModule("GameHelper"):GetAvailableInventorySpace()
            
            if availableSpace <= 0 then
                if not hasWarnedFull then
                    self.framework.UI.Library:Notify("Inventory full! Waiting for space...", 3)
                    hasWarnedFull = true
                end
                task.wait(2)
                continue
            else
                hasWarnedFull = false
            end
            
            local currentHatchAmount = originalHatchAmount
            
            if availableSpace < originalHatchAmount then
                if availableSpace >= 8 and originalHatchAmount == 8 then
                    currentHatchAmount = 8
                elseif availableSpace >= 3 then
                    currentHatchAmount = 3
                else
                    currentHatchAmount = 1
                end
                
                if currentHatchAmount ~= lastNotifiedAmount and self.framework.UI.Toggles.ShowNotifications.Value then
                    self.framework.UI.Library:Notify("Limited space: hatching " .. currentHatchAmount .. "x instead of " .. originalHatchAmount .. "x", 2)
                    lastNotifiedAmount = currentHatchAmount
                end
            else
                if lastNotifiedAmount ~= originalHatchAmount and self.framework.UI.Toggles.ShowNotifications.Value then
                    self.framework.UI.Library:Notify("Space available: back to " .. originalHatchAmount .. "x hatching", 2)
                    lastNotifiedAmount = originalHatchAmount
                end
            end
            
            -- Determine which egg to hatch
            local eggToHatch = Framework.State.selectedEgg
            
            if Framework.State.selectedEgg == "Best Affordable Egg" then
                local bestEgg, bestPrice, bestAvgMult = Framework:GetModule("GameHelper"):GetBestAffordableEgg()
                
                if bestEgg then
                    eggToHatch = bestEgg
                    
                    -- Smart hatch amount: find the best amount we can afford
                    local smartHatchAmount = currentHatchAmount
                    
                    -- Try preferred amounts in order: 8, 3, 1
                    if not Framework:GetModule("GameHelper"):CanAffordEgg(eggToHatch, currentHatchAmount) then
                        -- Can't afford current amount, try smaller amounts
                        if currentHatchAmount > 3 and Framework:GetModule("GameHelper"):CanAffordEgg(eggToHatch, 3) then
                            smartHatchAmount = 3
                        elseif currentHatchAmount > 1 and Framework:GetModule("GameHelper"):CanAffordEgg(eggToHatch, 1) then
                            smartHatchAmount = 1
                        else
                            -- Can't afford even 1, wait and retry
                            task.wait(1)
                            continue
                        end
                        
                        -- Notify about affordability adjustment
                        if smartHatchAmount ~= lastAffordableAmount and self.framework.UI.Toggles.ShowNotifications.Value then
                            self.framework.UI.Library:Notify("Best Affordable: Can only afford " .. smartHatchAmount .. "x " .. eggToHatch, 2)
                            lastAffordableAmount = smartHatchAmount
                        end
                    else
                        -- Reset notification tracker when we can afford the full amount again
                        if lastAffordableAmount ~= currentHatchAmount and self.framework.UI.Toggles.ShowNotifications.Value then
                            self.framework.UI.Library:Notify("Best Affordable: Back to " .. currentHatchAmount .. "x hatching", 2)
                            lastAffordableAmount = currentHatchAmount
                        end
                    end
                    
                    currentHatchAmount = smartHatchAmount
                else
                    -- Can't afford any egg, wait and retry
                    task.wait(1)
                    continue
                end
            end
            
            if Framework:GetModule("GameHelper"):CanAffordEgg(eggToHatch, currentHatchAmount) then
                pcall(function()
                    Framework.Remotes.openEgg:InvokeServer(eggToHatch, currentHatchAmount, {})
                end)
            end
            
            task.wait(0.1)
        end
    end)
    
    self.framework:AddTask("AutoHatchMain", hatchTask)

    self.framework.UI.Library:Notify("Auto Hatch started with smart inventory management", 3)
end

function AutoHatchModule:Stop()
    if not self.enabled then return end
    self.enabled = false
    self.framework.Stats.eggStats.isTracking = false
    
    -- Clean up all connections
    for name, _ in pairs(self.connections) do
        self.framework:RemoveConnection("AutoHatch_" .. name)
    end
    self.connections = {}
    
    -- Cancel tracked tasks
    self.framework:RemoveTask("AutoHatchMonitor")
    self.framework:RemoveTask("AutoHatchMain")
    
    self.framework.UI.Library:Notify("Auto Hatch stopped", 3)
end

Framework:RegisterModule("AutoHatch", AutoHatchModule)

-- Auto Buy Upgrades Module
local AutoBuyUpgradesModule = {
    enabled = false
}

function AutoBuyUpgradesModule:Init(fw)
    self.framework = fw
end

function AutoBuyUpgradesModule:GetUpgradeList(category)
    local success, result = pcall(function()
        if self.framework.Data.upgradeCategories[category] then
            local path = self.framework.Data.upgradeCategories[category].path
            local parts = {}
            for part in string.gmatch(path, "[^.]+") do
                table.insert(parts, part)
            end
            
            local current = p.PlayerGui
            for _, part in ipairs(parts) do
                current = current:FindFirstChild(part)
                if not current then return nil end
            end
            return current
        elseif self.framework.Data.gemShopUpgrades[category] then
            return p.PlayerGui.Tabs.Upgrades.Menu.Categories.Upgrades.Inner.List
        end
    end)
    return success and result or nil
end

function AutoBuyUpgradesModule:IsUpgradeAffordable(upgradeFrame, category)
    -- First check if it's island locked
    local islandLocked = upgradeFrame:FindFirstChild("IslandLock")
    if islandLocked and islandLocked.Visible then
        return false -- Can't buy if island locked
    end
    
    if self.framework.Data.upgradeCategories[category] then
        local locked = upgradeFrame:FindFirstChild("UpgradeLocked")
        if locked and locked.Visible then return false end
        
        local unlocked = upgradeFrame:FindFirstChild("Unlocked")
        if unlocked and unlocked.Visible then return false end
        
        return true
    else
        local completed = upgradeFrame:FindFirstChild("Completed")
        if completed and completed.Visible then return false end
        
        local gemsLabel = p.PlayerGui:FindFirstChild("Game")
        if not gemsLabel then return false end
        gemsLabel = gemsLabel:FindFirstChild("Left")
        if not gemsLabel then return false end
        gemsLabel = gemsLabel:FindFirstChild("Gems")
        if not gemsLabel then return false end
        gemsLabel = gemsLabel:FindFirstChild("Main")
        if not gemsLabel then return false end
        gemsLabel = gemsLabel:FindFirstChild("Amount")
        if not gemsLabel then return false end
        
        local gemsText = string.gsub(gemsLabel.Text, ",", "")
        local currentGems = 0
        
        local numPart = tonumber(string.match(gemsText, "([%d%.]+)"))
        if not numPart then return false end
        
        local suffix = string.match(gemsText, "([KMBTQSNODUkmbqsnodu]+)")
        if suffix then
            suffix = string.upper(suffix)
            local multipliers = {
                K = 1e3, M = 1e6, B = 1e9, T = 1e12,
                QD = 1e15, QN = 1e18, SX = 1e21, SP = 1e24,
                O = 1e27, N = 1e30, DC = 1e33, UD = 1e36,
                DD = 1e39, TD = 1e42
            }
            currentGems = numPart * (multipliers[suffix] or 1)
        else
            currentGems = numPart
        end
        
        local priceLabel = upgradeFrame:FindFirstChild("Upgrade")
        if not priceLabel then return false end
        priceLabel = priceLabel:FindFirstChild("Main")
        if not priceLabel then return false end
        priceLabel = priceLabel:FindFirstChild("Currency")
        if not priceLabel then return false end
        priceLabel = priceLabel:FindFirstChild("Amount")
        if not priceLabel then return false end
        
        local priceText = string.gsub(priceLabel.Text, ",", "")
        local price = 0
        
        local pricePart = tonumber(string.match(priceText, "([%d%.]+)"))
        if not pricePart then return false end
        
        local priceSuffix = string.match(priceText, "([KMBTQSNODUkmbqsnodu]+)")
        if priceSuffix then
            priceSuffix = string.upper(priceSuffix)
            local multipliers = {
                K = 1e3, M = 1e6, B = 1e9, T = 1e12,
                QD = 1e15, QN = 1e18, SX = 1e21, SP = 1e24,
                O = 1e27, N = 1e30, DC = 1e33, UD = 1e36,
                DD = 1e39, TD = 1e42
            }
            price = pricePart * (multipliers[priceSuffix] or 1)
        else
            price = pricePart
        end
        
        return currentGems >= price
    end
end

function AutoBuyUpgradesModule:GetHighestAffordableUpgrade(category)
    local list = self:GetUpgradeList(category)
    if not list then return nil, nil, nil end
    
    if self.framework.Data.gemShopUpgrades[category] then
        for _, child in pairs(list:GetChildren()) do
            if child:IsA("Frame") and child.Name == category then
                if self:IsUpgradeAffordable(child, category) then
                    return child, 0, category
                end
                break
            end
        end
    else
        local highest = nil
        local highestNum = 0
        local upgradeName = nil
        
        for _, child in pairs(list:GetChildren()) do
            if child:IsA("Frame") or child:IsA("GuiObject") then
                local num = tonumber(child.Name)
                if num and num > highestNum then
                    if self:IsUpgradeAffordable(child, category) then
                        highest = child
                        highestNum = num
                        upgradeName = self.framework.Data.upgradeCategories[category].param
                    end
                end
            end
        end
        
        return highest, highestNum, upgradeName
    end
    
    return nil, nil, nil
end

function AutoBuyUpgradesModule:BuyUpgrade(category, upgradeName)
    local categoryInfo = self.framework.Data.upgradeCategories[category]
    
    if categoryInfo then
        local remote = self.framework.Remotes[categoryInfo.remote == "UpgradeDoubleJump" and "doubleJump" or "buyUpgrade"]
        if not remote then return false end
        
        local success, result = pcall(function()
            return remote:InvokeServer(upgradeName)
        end)
        
        -- Only return true if the purchase was actually successful
        -- For these upgrades, the remote returns a result that indicates success
        return success and result ~= false and result ~= nil
    else
        if not self.framework.Remotes.buyUpgrade then return false end
        
        local success, result = pcall(function()
            return self.framework.Remotes.buyUpgrade:InvokeServer(upgradeName)
        end)
        
        return success and result ~= false and result ~= nil
    end
end

function AutoBuyUpgradesModule:Start()
    if self.enabled then return end
    self.enabled = true
    
    task.spawn(function()
        while self.enabled do
            if not self.enabled then break end
            
            for category, _ in pairs(self.framework.State.selectedUpgrades) do
                if not self.enabled then break end
                
                local upgradeFrame, upgradeNum, upgradeName = self:GetHighestAffordableUpgrade(category)
                
                if upgradeFrame and upgradeName then
                    local success = self:BuyUpgrade(category, upgradeName)
                    
                    -- Only notify if actually purchased
                    if success then
                        if self.framework.UI.Toggles.ShowNotifications and self.framework.UI.Toggles.ShowNotifications.Value then
                            self.framework.UI.Library:Notify("‚úì Bought: " .. category, 2)
                        end
                    end
                end
            end
            
            task.wait(self.framework.State.upgradeCheckDelay)
        end
    end)
    
    self.framework.UI.Library:Notify("Auto Buy Upgrades started", 3)
end

function AutoBuyUpgradesModule:Stop()
    if not self.enabled then return end
    self.enabled = false
    self.framework.UI.Library:Notify("Auto Buy Upgrades stopped", 3)
end

Framework:RegisterModule("AutoBuyUpgrades", AutoBuyUpgradesModule)

-- Get list of available pets (filtered by excluded rarities and equipped status, sorted)
local function getEnchantablePets(sortMethod, showIndividual)
    sortMethod = sortMethod or "Multiplier (Low to High)"
    showIndividual = showIndividual or false
    
    if showIndividual then
        -- Individual mode: Show each pet instance separately
        local petsArray = {}
        
        pcall(function()
            if Framework.Data.replicationData and Framework.Data.replicationData.Data and Framework.Data.replicationData.Data.Pets then
                for petId, petData in pairs(Framework.Data.replicationData.Data.Pets) do
                    if typeof(petData) == "table" and petData.Name then
                        local petStats = Framework.Data.petStats[petData.Name]
                        local rarity = petStats and petStats.Rarity or "Unknown"
                        local multiplier = petStats and petStats.Multiplier1 or 0
                        
                        -- Skip if rarity is excluded
                        if Framework.State.excludedEnchantRarities[rarity] then
                            -- Skip this pet
                        -- Skip if equipped and we're excluding equipped
                        elseif Framework.State.excludeEquippedEnchant and petData.Equipped == true then
                            -- Skip this pet
                        else
                            -- Get current enchant if any
                            local currentEnchant = Framework:GetModule("AutoEnchant"):GetCurrentEnchant(petId)
                            local enchantDisplay = currentEnchant and (" [" .. currentEnchant .. "]") or ""
                            
                            -- Get tier
                            local tier = petData.Tier or "Normal"
                            local tierDisplay = tier ~= "Normal" and (" {" .. tier .. "}") or ""
                            
                            table.insert(petsArray, {
                                id = petId,
                                name = petData.Name,
                                rarity = rarity,
                                multiplier = multiplier,
                                equipped = petData.Equipped or false,
                                enchant = currentEnchant,
                                tier = tier,
                                display = petData.Name .. tierDisplay .. enchantDisplay .. " (" .. Framework:GetModule("Format"):FormatNumber(multiplier) .. "x)" .. (petData.Equipped and " [EQUIPPED]" or "") .. " #" .. string.sub(petId, 1, 6)
                            })
                        end
                    end
                end
            end
        end)
        
        -- Sort individual pets
        if sortMethod == "Multiplier (Low to High)" then
            table.sort(petsArray, function(a, b) 
                if a.multiplier == b.multiplier then return a.id < b.id end
                return a.multiplier < b.multiplier 
            end)
        elseif sortMethod == "Multiplier (High to Low)" then
            table.sort(petsArray, function(a, b) 
                if a.multiplier == b.multiplier then return a.id < b.id end
                return a.multiplier > b.multiplier 
            end)
        elseif sortMethod == "Rarity (Low to High)" then
            table.sort(petsArray, function(a, b)
                local rarityA = Framework:GetModule("GameHelper"):GetRarityRank(a.rarity)
                local rarityB = Framework:GetModule("GameHelper"):GetRarityRank(b.rarity)
                if rarityA == rarityB then return a.id < b.id end
                return rarityA < rarityB
            end)
        elseif sortMethod == "Rarity (High to Low)" then
            table.sort(petsArray, function(a, b)
                local rarityA = Framework:GetModule("GameHelper"):GetRarityRank(a.rarity)
                local rarityB = Framework:GetModule("GameHelper"):GetRarityRank(b.rarity)
                if rarityA == rarityB then return a.id < b.id end
                return rarityA > rarityB
            end)
        end
        
        -- Build display list
        local displayList = {}
        for _, petInfo in ipairs(petsArray) do
            table.insert(displayList, {
                id = petInfo.id,
                name = petInfo.name,
                display = petInfo.display
            })
        end
        
        return #displayList > 0 and displayList or {{id = "none", name = "None", display = "No pets available"}}
    else
        -- Grouped mode: Show pet names with counts (original behavior)
        local petsByName = {}
        
        pcall(function()
            if Framework.Data.replicationData and Framework.Data.replicationData.Data and Framework.Data.replicationData.Data.Pets then
                for petId, petData in pairs(Framework.Data.replicationData.Data.Pets) do
                    if typeof(petData) == "table" and petData.Name then
                        local petStats = Framework.Data.petStats[petData.Name]
                        local rarity = petStats and petStats.Rarity or "Unknown"
                        local multiplier = petStats and petStats.Multiplier1 or 0
                        
                        -- Skip if rarity is excluded
                        if Framework.State.excludedEnchantRarities[rarity] then
                            -- Skip this pet
                        -- Skip if equipped and we're excluding equipped
                        elseif Framework.State.excludeEquippedEnchant and petData.Equipped == true then
                            -- Skip this pet
                        else
                            -- This pet passes all filters
                            if not petsByName[petData.Name] then
                                petsByName[petData.Name] = {
                                    name = petData.Name,
                                    rarity = rarity,
                                    multiplier = multiplier,
                                    count = 0,
                                    ids = {}
                                }
                            end
                            
                            petsByName[petData.Name].count = petsByName[petData.Name].count + 1
                            table.insert(petsByName[petData.Name].ids, petId)
                        end
                    end
                end
            end
        end)
        
        -- Convert to array for sorting
        local petsArray = {}
        for _, petInfo in pairs(petsByName) do
            table.insert(petsArray, petInfo)
        end
        
        -- Sort by method
        if sortMethod == "Multiplier (Low to High)" then
            table.sort(petsArray, function(a, b) 
                if a.multiplier == b.multiplier then return a.name < b.name end
                return a.multiplier < b.multiplier 
            end)
        elseif sortMethod == "Multiplier (High to Low)" then
            table.sort(petsArray, function(a, b) 
                if a.multiplier == b.multiplier then return a.name < b.name end
                return a.multiplier > b.multiplier 
            end)
        elseif sortMethod == "Owned (High to Low)" then
            table.sort(petsArray, function(a, b)
                if a.count == b.count then return a.name < b.name end
                return a.count > b.count
            end)
        elseif sortMethod == "Owned (Low to High)" then
            table.sort(petsArray, function(a, b)
                if a.count == b.count then return a.name < b.name end
                return a.count < b.count
            end)
        end
        
        -- Build display list with count
        local displayList = {}
        for _, petInfo in ipairs(petsArray) do
            if sortMethod == "Multiplier (Low to High)" or sortMethod == "Multiplier (High to Low)" then
                table.insert(displayList, {
                    name = petInfo.name,
                    count = petInfo.count,
                    ids = petInfo.ids,
                    display = petInfo.name .. " (" .. Framework:GetModule("Format"):FormatNumber(petInfo.multiplier) .. "x) [x" .. petInfo.count .. "]"
                })
            else
                table.insert(displayList, {
                    name = petInfo.name,
                    count = petInfo.count,
                    ids = petInfo.ids,
                    display = petInfo.name .. " (x" .. petInfo.count .. " owned)"
                })
            end
        end
        
        return #displayList > 0 and displayList or {{name = "None", display = "No pets available", count = 0, ids = {}}}
    end
end

print("‚úì Feature modules loaded")
print("‚úì Initializing UI components...")

-- UI Update Manager
local UIUpdateManager = {
    updates = {},
    updateRate = 0.5,
    running = false
}

function UIUpdateManager:Register(name, updateFunc)
    self.updates[name] = {func = updateFunc, enabled = true}
end

function UIUpdateManager:Enable(name)
    if self.updates[name] then
        self.updates[name].enabled = true
    end
end

function UIUpdateManager:Disable(name)
    if self.updates[name] then
        self.updates[name].enabled = false
    end
end

function UIUpdateManager:Start()
    if self.running then return end
    self.running = true
    
    task.spawn(function()
        while self.running and getgenv().TapSimLoaded do
            for name, data in pairs(self.updates) do
                if data.enabled then
                    pcall(data.func)
                end
            end
            task.wait(self.updateRate)
        end
    end)
end

function UIUpdateManager:Stop()
    self.running = false
end

Framework:RegisterModule("UIUpdate", UIUpdateManager)

-- UI Builder
local function BuildUI()
    local FarmTab = Framework.UI.Tabs.Farm
    local EggTab = Framework.UI.Tabs.Egg
    local MachinesTab = Framework.UI.Tabs.Machines
    local PetsTab = Framework.UI.Tabs.Pets
    local MiscTab = Framework.UI.Tabs.Misc
    local SettingsTab = Framework.UI.Tabs.Settings
    
    local AutoFarmBox = FarmTab:AddLeftGroupbox("Auto Farm")
    local UpgradeBox = FarmTab:AddLeftGroupbox("Auto Buy Upgrades")
    local RebirthBox = FarmTab:AddRightGroupbox("Rebirth")
    
    local EggBox = EggTab:AddLeftGroupbox("Egg Hatching")
    local AutoDeleteBox = EggTab:AddLeftGroupbox("Auto Delete Pets")
    local EggInfoBox = EggTab:AddRightGroupbox("Info")
    
    -- Machines Tab (moved from old Pet tab)
    local GoldenCraftBox = MachinesTab:AddLeftGroupbox("Golden Crafting")
    local RainbowCraftBox = MachinesTab:AddRightGroupbox("Rainbow Crafting")
    local RainbowStatusBox = MachinesTab:AddRightGroupbox("Rainbow Status")
    
    -- New Pets Tab (currently empty, ready for pet-related features)
    local PetManagementBox = PetsTab:AddLeftGroupbox("Pet Management")
    local PetInfoBox = PetsTab:AddRightGroupbox("Pet Information")
    
    local TeleportBox = MiscTab:AddLeftGroupbox("Teleports")
    
    local UISettings = SettingsTab:AddLeftGroupbox("UI Settings")
    local MenuSettings = SettingsTab:AddRightGroupbox("Menu")
    
    -- Auto Tap
    AutoFarmBox:AddToggle("AutoTap", {
        Text = "Auto Tap",
        Default = false,
        Tooltip = "Automatically tap at maximum speed",
        Callback = function(Value)
            if Value then
                Framework:GetModule("AutoTap"):Start()
            else
                Framework:GetModule("AutoTap"):Stop()
            end
        end
    })
    
    -- Auto Buy Upgrades
    local upgradeList = {"Double Jumps", "Rebirth Buttons"}
    for upgradeName, _ in pairs(Framework.Data.gemShopUpgrades) do
        table.insert(upgradeList, upgradeName)
    end
    
    UpgradeBox:AddDropdown("UpgradeCategory", {
        Values = upgradeList,
        Default = {},
        Multi = true,
        Text = "Select Upgrades",
        Tooltip = "Select which upgrades to auto-buy (multi-select)",
        Callback = function(Value)
            Framework.State.selectedUpgrades = Value
            local count = 0
            for _ in pairs(Value) do count = count + 1 end
            Framework.UI.Library:Notify("Selected " .. count .. " upgrade(s)", 2)
        end
    })
    
    UpgradeBox:AddSlider("UpgradeCheckDelay", {
        Text = "Check Delay (seconds)",
        Default = 2,
        Min = 0.5,
        Max = 10,
        Rounding = 1,
        Compact = false,
        Tooltip = "How often to check for affordable upgrades",
        Callback = function(Value)
            Framework.State.upgradeCheckDelay = Value
        end
    })
    
    UpgradeBox:AddToggle("AutoBuyUpgrades", {
        Text = "Auto Buy Upgrades",
        Default = false,
        Tooltip = "Automatically buy the highest affordable upgrade from selected categories",
        Callback = function(Value)
            if Value then
                local count = 0
                for _ in pairs(Framework.State.selectedUpgrades) do count = count + 1 end
                
                if count == 0 then
                    Framework.UI.Library:Notify("Error: No upgrades selected!", 5)
                    Framework.UI.Toggles.AutoBuyUpgrades:SetValue(false)
                    return
                end
                
                Framework:GetModule("AutoBuyUpgrades"):Start()
            else
                Framework:GetModule("AutoBuyUpgrades"):Stop()
            end
        end
    })
    
    -- Rebirth
    RebirthBox:AddDropdown("RebirthAmount", {
        Values = Framework.Data.rebirthList,
        Default = 1,
        Multi = false,
        Text = "Select Rebirth Amount",
        Tooltip = "Choose which rebirth tier to use",
        Callback = function(Value)
            if Value == "Max Unlocked" then
                Framework.State.selectedRebirthButton = "Max"
            else
                for i, displayText in ipairs(Framework.Data.rebirthList) do
                    if displayText == Value then
                        Framework.State.selectedRebirthButton = i - 1
                        break
                    end
                end
            end
            Framework.UI.Library:Notify("Selected: " .. Value, 2)
        end
    })
    
    -- After the RebirthAmount dropdown is created, add this:

-- Auto-update rebirth list every 2 seconds
task.spawn(function()
    while getgenv().TapSimLoaded do
        task.wait(2)  -- Very responsive updates
        
        local updated = Framework:GetModule("DataLoader"):RefreshRebirthList()
        
        if updated and Framework.UI.Toggles.ShowNotifications and Framework.UI.Toggles.ShowNotifications.Value then
            local count = #Framework.Data.rebirthList - 1 -- -1 for "Max Unlocked"
            Framework.UI.Library:Notify("üîÑ New rebirth unlocked! (" .. count .. " available)", 2)
        end
    end
end)

    RebirthBox:AddSlider("RebirthDelay", {
        Text = "Rebirth Delay (seconds)",
        Default = 0,
        Min = 0,
        Max = 30,
        Rounding = 1,
        Compact = false,
        Tooltip = "Delay between rebirths",
        Callback = function(Value)
            Framework.State.rebirthDelay = Value
        end
    })
    
    

    RebirthBox:AddToggle("AutoRebirth", {
        Text = "Auto Rebirth",
        Default = false,
        Tooltip = "Automatically rebirth when available",
        Callback = function(Value)
            if Value then
                Framework:GetModule("AutoRebirth"):Start()
            else
                Framework:GetModule("AutoRebirth"):Stop()
            end
        end
    })
    
    RebirthBox:AddToggle("AutoUnlimitedRebirth", {
        Text = "Auto Unlimited Rebirth",
        Default = false,
        Tooltip = "Automatically rebirth using unlimited mode (Requires Unlimited Rebirth Gamepass)",
        Callback = function(Value)
            if Value then
                task.spawn(function()
                    while Framework.UI.Toggles.AutoUnlimitedRebirth.Value do
                        pcall(function()
                            Framework.Remotes.rebirth:InvokeServer(1, 1)
                        end)
                        
                        task.wait(Framework.State.rebirthDelay > 0 and Framework.State.rebirthDelay or 0.1)
                    end
                end)
                Framework.UI.Library:Notify("Auto Unlimited Rebirth started", 3)
            else
                Framework.UI.Library:Notify("Auto Unlimited Rebirth stopped", 3)
            end
        end
    })
    
    -- Egg Hatching
    EggBox:AddDropdown("EggSelect", {
    Values = (function()
        local eggs = {"Best Affordable Egg"}
        for _, egg in ipairs(Framework.Data.eggList) do
            table.insert(eggs, egg)
        end
        return eggs
    end)(),
    Default = 1,
    Multi = false,
    Text = "Select Egg",
    Tooltip = "Choose which egg to hatch",
    Callback = function(Value)
        if Value == "Best Affordable Egg" then
            Framework.State.selectedEgg = "Best Affordable Egg"
            Framework.UI.Library:Notify("Selected: Best Affordable Egg (Smart value-based selection)", 2)
        else
            Framework.State.selectedEgg = string.match(Value, "^(.-)%s*%[?EXCLUSIVE%]?%s*%(") or string.match(Value, "^(.-)%s*%(")
            Framework.UI.Library:Notify("Selected: " .. Framework.State.selectedEgg, 2)
        end
    end
})
    
    EggBox:AddDropdown("HatchAmount", {
        Values = {"1", "3", "8 (Gamepass)"},
        Default = 1,
        Multi = false,
        Text = "Hatch Amount",
        Tooltip = "Number of eggs to hatch at once",
        Callback = function(Value)
            if Value == "1" then
                Framework.State.hatchAmount = 1
            elseif Value == "3" then
                Framework.State.hatchAmount = 3
            elseif Value == "8 (Gamepass)" then
                Framework.State.hatchAmount = 8
            end
            Framework.UI.Library:Notify("Hatch amount: " .. Framework.State.hatchAmount, 2)
        end
    })
    
    EggBox:AddToggle("AutoHatch", {
        Text = "Auto Hatch Eggs",
        Default = false,
        Tooltip = "Automatically hatch selected eggs with smart inventory management",
        Callback = function(Value)
            if Value then
                Framework:GetModule("AutoHatch"):Start()
            else
                Framework:GetModule("AutoHatch"):Stop()
            end
        end
    })
    
    -- Egg Info Box
    EggInfoBox:AddLabel("Egg Statistics")
    EggInfoBox:AddDivider()
    
    Framework.UI.Labels.currentEgg = EggInfoBox:AddLabel("Current Egg: None")
    Framework.UI.Labels.eggCost = EggInfoBox:AddLabel("Egg Cost: 0")
    Framework.UI.Labels.hatchMode = EggInfoBox:AddLabel("Hatch Mode: 1x")
    EggInfoBox:AddDivider()
    Framework.UI.Labels.totalHatched = EggInfoBox:AddLabel("Total Hatched: 0")
    Framework.UI.Labels.totalSpent = EggInfoBox:AddLabel("Total Spent: 0")
    Framework.UI.Labels.timeElapsed = EggInfoBox:AddLabel("Time Elapsed: 0s")
    EggInfoBox:AddDivider()
    Framework.UI.Labels.eggsPerMin = EggInfoBox:AddLabel("Eggs/Min: 0")
    Framework.UI.Labels.clicksPerMin = EggInfoBox:AddLabel("Clicks/Min: 0")
    Framework.UI.Labels.avgCost = EggInfoBox:AddLabel("Avg Cost: 0")
    EggInfoBox:AddDivider()
    Framework.UI.Labels.bestPet = EggInfoBox:AddLabel("Best Possible: Unknown")
    EggInfoBox:AddDivider()
    Framework.UI.Labels.inventoryStatus = EggInfoBox:AddLabel("Inventory: 0/100 (100 free)")
    
    -- Smart inventory tracking using Eggs leaderstats + replication data
    local inventoryTracker = {
        current = 0,
        max = 100,
        lastEggsValue = 0,
        needsUpdate = true
    }
    
    -- Function to count pets from replication data
    local function updateInventoryFromReplication()
        local success = pcall(function()
            local replicationModule = rs:FindFirstChild("Game")
            if not replicationModule then return end
            
            local repMod = replicationModule:FindFirstChild("Replication")
            if not repMod or not repMod:IsA("ModuleScript") then return end
            
            local freshData = require(repMod)
            if not freshData or not freshData.Data then return end
            
            local data = freshData.Data
            
            -- Count current pets
            local count = 0
            if data.Pets then
                for _ in pairs(data.Pets) do
                    count = count + 1
                end
            end
            
            inventoryTracker.current = count
            
            -- Get max slots
            if data.PetSlots then
                local maxSlots = data.PetSlots
                if type(maxSlots) == "table" then
                    maxSlots = maxSlots.Value or maxSlots[1] or 100
                end
                inventoryTracker.max = maxSlots
            elseif data.MaxPets then
                local maxPets = data.MaxPets
                if type(maxPets) == "table" then
                    maxPets = maxPets.Value or maxPets[1] or 100
                end
                inventoryTracker.max = maxPets
            end
        end)
        
        return success
    end
    
    -- Initial update
    updateInventoryFromReplication()
    
    -- Monitor Eggs leaderstats value for changes (triggers inventory refresh)
    task.spawn(function()
        local leaderstats = p:WaitForChild("leaderstats")
        local eggsValue = leaderstats:WaitForChild("Eggs")
        
        inventoryTracker.lastEggsValue = eggsValue.Value
        
        -- Watch for Eggs value changes
        eggsValue.Changed:Connect(function(newValue)
            if newValue ~= inventoryTracker.lastEggsValue then
                inventoryTracker.lastEggsValue = newValue
                -- Eggs hatched! Refresh inventory count
                task.wait(0.2) -- Small delay for server to update
                updateInventoryFromReplication()
            end
        end)
    end)
    
    -- Also periodically refresh (backup method)
    task.spawn(function()
        while getgenv().TapSimLoaded do
            task.wait(3) -- Check every 3 seconds
            updateInventoryFromReplication()
        end
    end)
    
    -- Register inventory status update (displays tracked count)
    UIUpdateManager:Register("inventoryStatus", function()
        local free = math.max(0, inventoryTracker.max - inventoryTracker.current)
        Framework.UI.Labels.inventoryStatus:SetText("Inventory: " .. inventoryTracker.current .. "/" .. inventoryTracker.max .. " (" .. free .. " free)")
    end)
    
    -- Register egg stats update
    UIUpdateManager:Register("eggStats", function()

    -- Register inventory status update (uses robust method like Auto Hatch)
    UIUpdateManager:Register("inventoryStatus", function()
        local current, max = Framework:GetModule("GameHelper"):GetInventorySpace()
        
        -- If we got valid data, display it
        if current and max and max > 0 then
            local free = math.max(0, max - current)
            Framework.UI.Labels.inventoryStatus:SetText("Inventory: " .. current .. "/" .. max .. " (" .. free .. " free)")
        else
            -- Fallback display if data unavailable
            Framework.UI.Labels.inventoryStatus:SetText("Inventory: Loading...")
        end
    end)
    local displayEgg = Framework.State.selectedEgg
    
    -- If using Best Affordable, show the actual egg being hatched
    if Framework.State.selectedEgg == "Best Affordable Egg" then
        local bestEgg, bestPrice, bestAvgMult = Framework:GetModule("GameHelper"):GetBestAffordableEgg()
        
        if bestEgg then
            displayEgg = bestEgg .. " [Auto, " .. Framework:GetModule("Format"):FormatNumber(math.floor(bestAvgMult)) .. "x avg]"
        else
            displayEgg = "Best Affordable Egg (None affordable)"
        end
    end
    
    Framework.UI.Labels.currentEgg:SetText("Current Egg: " .. displayEgg)
        
        -- Get egg cost (handle Best Affordable Egg)
        local eggCost = 0
        local eggForCost = Framework.State.selectedEgg
        
        -- If using Best Affordable, get the actual egg being hatched
        if Framework.State.selectedEgg == "Best Affordable Egg" then
            local bestEgg, bestPrice = Framework:GetModule("GameHelper"):GetBestAffordableEgg()
            if bestEgg then
                eggForCost = bestEgg
            end
        end
        
        if Framework.Data.eggData[eggForCost] then
            eggCost = Framework.Data.eggData[eggForCost].Price
        end
        Framework.UI.Labels.eggCost:SetText("Egg Cost: " .. Framework:GetModule("Format"):FormatNumber(eggCost) .. " " .. string.lower(Framework.Data.primaryCurrency))
        Framework.UI.Labels.hatchMode:SetText("Hatch Mode: " .. Framework.State.hatchAmount .. "x")
        
        local eggForBestPet = Framework.State.selectedEgg
    
    -- If using Best Affordable, get the actual egg
    if Framework.State.selectedEgg == "Best Affordable Egg" then
        local bestEgg, bestPrice = Framework:GetModule("GameHelper"):GetBestAffordableEgg()
        if bestEgg then
            eggForBestPet = bestEgg
        else
            Framework.UI.Labels.bestPet:SetText("Best Possible: None (No affordable eggs)")
            return -- Skip the rest if no egg is affordable
        end
    end
    
    local bestPet = Framework:GetModule("GameHelper"):GetBestPetFromEgg(eggForBestPet)
    Framework.UI.Labels.bestPet:SetText("Best Possible: " .. bestPet)
        
        if Framework.Stats.eggStats.isTracking then
            local elapsed = tick() - Framework.Stats.eggStats.startTime
            local minutes = math.floor(elapsed / 60)
            local seconds = math.floor(elapsed % 60)
            local timeStr = minutes > 0 and (minutes .. "m " .. seconds .. "s") or (seconds .. "s")
            
            Framework.UI.Labels.totalHatched:SetText("Total Hatched: " .. Framework:GetModule("Format"):FormatNumber(Framework.Stats.eggStats.totalHatched))
            Framework.UI.Labels.totalSpent:SetText("Total Spent: " .. Framework:GetModule("Format"):FormatNumber(Framework.Stats.eggStats.totalClicksSpent) .. " " .. string.lower(Framework.Data.primaryCurrency))
            Framework.UI.Labels.timeElapsed:SetText("Time Elapsed: " .. timeStr)
            
            if elapsed > 0 then
                local eggsPerMin = (Framework.Stats.eggStats.totalHatched / elapsed) * 60
                local clicksPerMin = (Framework.Stats.eggStats.totalClicksSpent / elapsed) * 60
                
                Framework.UI.Labels.eggsPerMin:SetText("Eggs/Min: " .. Framework:GetModule("Format"):FormatNumber(math.floor(eggsPerMin)))
                Framework.UI.Labels.clicksPerMin:SetText(Framework.Data.primaryCurrency .. "/Min: " .. Framework:GetModule("Format"):FormatNumber(math.floor(clicksPerMin)))
            end
            
            if Framework.Stats.eggStats.totalHatched > 0 then
                local avgCost = Framework.Stats.eggStats.totalClicksSpent / Framework.Stats.eggStats.totalHatched
                Framework.UI.Labels.avgCost:SetText("Avg Cost: " .. Framework:GetModule("Format"):FormatNumber(math.floor(avgCost)) .. " " .. string.lower(Framework.Data.primaryCurrency))
            end
        else
            Framework.UI.Labels.totalHatched:SetText("Total Hatched: 0")
            Framework.UI.Labels.totalSpent:SetText("Total Spent: 0 " .. string.lower(Framework.Data.primaryCurrency))
            Framework.UI.Labels.timeElapsed:SetText("Time Elapsed: 0s")
            Framework.UI.Labels.eggsPerMin:SetText("Eggs/Min: 0")
            Framework.UI.Labels.clicksPerMin:SetText(Framework.Data.primaryCurrency .. "/Min: 0")
            Framework.UI.Labels.avgCost:SetText("Avg Cost: 0 " .. string.lower(Framework.Data.primaryCurrency))
        end
    end)
    
-- Auto Delete Pets
local deleteEggList = {}
local deleteEggListWithPrices = {}

for eggName, _ in pairs(Framework.Data.eggPetsData) do
    local price = 0
    if Framework.Data.eggData[eggName] then
        price = Framework.Data.eggData[eggName].Price
    end
    
    table.insert(deleteEggListWithPrices, {
        name = eggName,
        price = price,
        display = eggName .. " (" .. Framework:GetModule("Format"):FormatNumber(price) .. " " .. string.lower(Framework.Data.primaryCurrency) .. ")"
    })
end

table.sort(deleteEggListWithPrices, function(a, b)
    return a.price < b.price
end)

for _, eggInfo in ipairs(deleteEggListWithPrices) do
    table.insert(deleteEggList, eggInfo.display)
end

if #deleteEggList == 0 then
    deleteEggList = {"Basic (0 " .. string.lower(Framework.Data.primaryCurrency) .. ")"}
end

-- Global rarity-based auto-delete (applies to ALL eggs)
Framework.State.globalDeleteRarities = {}
Framework.State.globalDeleteMultiplierThreshold = 0

-- Helper to get all pets of specific rarities from an egg
local function getPetsByRarity(eggName, selectedRarities)
    local pets = Framework.Data.eggPetsData[eggName] or {}
    local matchingPets = {}
    
    for _, petData in ipairs(pets) do
        if selectedRarities[petData.Rarity] then
            table.insert(matchingPets, petData.Name)
        end
    end
    
    return matchingPets
end

-- Track rarity-based deletions separately
Framework.State.selectedDeleteRarities = {}

local function getEggNameFromDisplay(displayString)
    return string.match(displayString, "^(.-)%s*%(") or displayString
end

local function getPetDisplayList(eggDisplayName)
    local eggName = getEggNameFromDisplay(eggDisplayName)
    local pets = Framework.Data.eggPetsData[eggName] or {}
    
    local sortedPets = {}
    for _, petData in ipairs(pets) do
        table.insert(sortedPets, petData)
    end
    
    table.sort(sortedPets, function(a, b)
        return a.Chance > b.Chance
    end)
    
    local displayList = {}
    for _, petData in ipairs(sortedPets) do
        table.insert(displayList, petData.Display)
    end
    return displayList
end

-- Helper function to apply ALL auto-delete configurations at once
local function applyAllAutoDeletes()
    if not Framework.Remotes.autoDelete then return end
    
    -- Build complete delete data for ALL configured eggs
    local deleteData = {}
    local totalEggs = 0
    local totalPets = 0
    
    -- First, add global filters (rarity + multiplier) to ALL eggs
    local hasGlobalRarityFilter = next(Framework.State.globalDeleteRarities) ~= nil
    local hasGlobalMultiplierFilter = Framework.State.globalDeleteMultiplierThreshold > 0
    
    if hasGlobalRarityFilter or hasGlobalMultiplierFilter then
        for eggName, pets in pairs(Framework.Data.eggPetsData) do
            local petsToDelete = {}
            
            for _, petData in ipairs(pets) do
                local shouldDelete = false
                
                -- Check rarity filter
                if hasGlobalRarityFilter and Framework.State.globalDeleteRarities[petData.Rarity] then
                    shouldDelete = true
                end
                
                -- Check multiplier filter
                if hasGlobalMultiplierFilter then
                    local petStats = Framework.Data.petStats[petData.Name]
                    if petStats then
                        local multiplier = petStats.Multiplier1 or 0
                        if multiplier < Framework.State.globalDeleteMultiplierThreshold then
                            shouldDelete = true
                        end
                    end
                end
                
                if shouldDelete then
                    table.insert(petsToDelete, petData.Name)
                end
            end
            
            if #petsToDelete > 0 then
                deleteData[eggName] = petsToDelete
            end
        end
    end
    
    -- Then, merge in individual pet selections (avoid duplicates)
    for eggName, petDisplayStrings in pairs(Framework.State.allDeleteSelections) do
        -- Extract pet names from display strings
        local petsArray = {}
        for displayString, _ in pairs(petDisplayStrings) do
            local petName = string.match(displayString, "^(.-)%s*%[")
            if petName then
                table.insert(petsArray, petName)
            end
        end
        
        if #petsArray > 0 then
            if not deleteData[eggName] then
                deleteData[eggName] = {}
            end
            
            -- Add individual pets (avoid duplicates from rarity filter)
            local existingPets = {}
            for _, petName in ipairs(deleteData[eggName]) do
                existingPets[petName] = true
            end
            
            for _, petName in ipairs(petsArray) do
                if not existingPets[petName] then
                    table.insert(deleteData[eggName], petName)
                end
            end
        end
    end
    
    -- Count totals
    for eggName, pets in pairs(deleteData) do
        if #pets > 0 then
            totalEggs = totalEggs + 1
            totalPets = totalPets + #pets
        end
    end
    
    -- Send ALL configurations to the server at once
    local success = pcall(function()
        Framework.Remotes.autoDelete:FireServer(deleteData)
    end)
    
    if success and totalEggs > 0 then
        if Framework.UI.Toggles.ShowNotifications and Framework.UI.Toggles.ShowNotifications.Value then
            Framework.UI.Library:Notify("Applied auto-delete: " .. totalEggs .. " egg(s), " .. totalPets .. " pet type(s)", 2)
        end
    end
end

-- Helper function to get currently saved selections for an egg
local function getSavedSelectionsForEgg(eggName)
    return Framework.State.allDeleteSelections[eggName] or {}
end

-- Helper function to restore dropdown selection from saved state
local function restoreDropdownSelection(eggName)
    local savedSelections = getSavedSelectionsForEgg(eggName)
    if savedSelections and next(savedSelections) then
        Framework.UI.Options.DeletePetsSelect:SetValue(savedSelections)
    else
        Framework.UI.Options.DeletePetsSelect:SetValue({})
    end
end

Framework.State.selectedDeleteEgg = getEggNameFromDisplay(deleteEggList[1])

Framework.State.selectedDeleteEgg = getEggNameFromDisplay(deleteEggList[1])

AutoDeleteBox:AddLabel("Global Rarity Filter (All Eggs)")
AutoDeleteBox:AddDropdown("GlobalDeleteRarities", {
    Values = (function()
        local rarities = Framework:GetModule("DataLoader"):GetAllRarities()
        return #rarities > 0 and rarities or {"Common", "Rare", "Epic"}
    end)(),
    Default = {},
    Multi = true,
    Text = "Delete Rarities (Global)",
    Tooltip = "All pets of selected rarities will be deleted from EVERY egg automatically",
    Callback = function(Value)
        Framework.State.globalDeleteRarities = Value
        
        -- Apply to all eggs
        applyAllAutoDeletes()
        
        local count = 0
        local rarityList = {}
        for rarity, _ in pairs(Value) do
            count = count + 1
            table.insert(rarityList, rarity)
        end
        
        if count > 0 then
            if Framework.UI.Toggles.ShowNotifications and Framework.UI.Toggles.ShowNotifications.Value then
                Framework.UI.Library:Notify("Globally deleting: " .. table.concat(rarityList, ", ") .. " from ALL eggs", 3)
            end
        else
            if Framework.UI.Toggles.ShowNotifications and Framework.UI.Toggles.ShowNotifications.Value then
                Framework.UI.Library:Notify("Global rarity filter cleared", 2)
            end
        end
    end
})

AutoDeleteBox:AddInput("GlobalDeleteMultiplier", {
    Default = "0",
    Numeric = false,
    Finished = true,
    Text = "Delete Below Multiplier",
    Tooltip = "Auto-delete any pet with base multiplier below this value (0 = disabled). Supports shorthand: 30k, 1.5M, 2B, etc.",
    Placeholder = "e.g., 1000 or 30k or 1.5M",
    Callback = function(Value)
        -- Parse shorthand notation (30k, 1.5M, 2B, etc.)
        local threshold = 0
        
        if Value and Value ~= "" then
            -- Remove commas and spaces
            Value = string.gsub(Value, ",", "")
            Value = string.gsub(Value, "%s+", "")
            
            -- Extract number and suffix
            local numPart = tonumber(string.match(Value, "([%d%.]+)"))
            
            if numPart then
                local suffix = string.match(Value, "([KMBTQSNODUkmbqsnodu]+)$")
                
                if suffix then
                    suffix = string.upper(suffix)
                    local multipliers = {
                        K = 1e3,
                        M = 1e6,
                        B = 1e9,
                        T = 1e12,
                        QD = 1e15,
                        QN = 1e18,
                        SX = 1e21,
                        SP = 1e24,
                        O = 1e27,
                        N = 1e30,
                        DC = 1e33,
                        UD = 1e36,
                        DD = 1e39,
                        TD = 1e42
                    }
                    
                    threshold = numPart * (multipliers[suffix] or 1)
                else
                    threshold = numPart
                end
            end
        end
        
        Framework.State.globalDeleteMultiplierThreshold = threshold
        
        -- Apply to all eggs
        applyAllAutoDeletes()
        
        if threshold > 0 then
            if Framework.UI.Toggles.ShowNotifications and Framework.UI.Toggles.ShowNotifications.Value then
                Framework.UI.Library:Notify("Globally deleting pets below " .. Framework:GetModule("Format"):FormatNumber(threshold) .. "x multiplier", 3)
            end
        else
            if Framework.UI.Toggles.ShowNotifications and Framework.UI.Toggles.ShowNotifications.Value then
                Framework.UI.Library:Notify("Multiplier filter disabled", 2)
            end
        end
    end
})

AutoDeleteBox:AddDivider()
AutoDeleteBox:AddLabel("Per-Egg Pet Selection")

AutoDeleteBox:AddDropdown("DeleteEggSelect", {
    Values = deleteEggList,
    Default = 1,
    Multi = false,
    Text = "Select Egg",
    Tooltip = "Choose which egg's pets to configure auto-delete for",
    Callback = function(Value)
        Framework.State.selectedDeleteEgg = getEggNameFromDisplay(Value)
        
        -- Update pet dropdown with pets from selected egg
        local petDisplayList = getPetDisplayList(Value)
        Framework.UI.Options.DeletePetsSelect:SetValues(petDisplayList)
        
        -- Restore saved selections for this egg
        restoreDropdownSelection(Framework.State.selectedDeleteEgg)
        
        if Framework.UI.Toggles.ShowNotifications and Framework.UI.Toggles.ShowNotifications.Value then
            local count = 0
            local saved = getSavedSelectionsForEgg(Framework.State.selectedDeleteEgg)
            for _ in pairs(saved) do count = count + 1 end
            
            if count > 0 then
                Framework.UI.Library:Notify("Selected egg: " .. Framework.State.selectedDeleteEgg .. " (" .. count .. " pets configured)", 2)
            else
                Framework.UI.Library:Notify("Selected egg: " .. Framework.State.selectedDeleteEgg, 2)
            end
        end
    end
})

AutoDeleteBox:AddDropdown("DeletePetsSelect", {
    Values = getPetDisplayList(deleteEggList[1]),
    Default = {},
    Multi = true,
    Text = "Select Pets to Auto-Delete",
    Tooltip = "Pets selected here will be automatically deleted when hatched",
    Callback = function(Value)
        local currentEgg = Framework.State.selectedDeleteEgg
        
        -- Save selection for this egg
        Framework.State.allDeleteSelections[currentEgg] = Value
        
        -- Apply ALL auto-delete configurations (not just current egg)
        applyAllAutoDeletes()
        
        local count = 0
        for _ in pairs(Value) do count = count + 1 end
        
        if count > 0 then
            if Framework.UI.Toggles.ShowNotifications and Framework.UI.Toggles.ShowNotifications.Value then
                Framework.UI.Library:Notify("Configured " .. count .. " pet type(s) for " .. currentEgg, 2)
            end
        end
    end
})

AutoDeleteBox:AddButton({
    Text = "Clear Current Egg",
    Func = function()
        if not Framework.Remotes.autoDelete then
            Framework.UI.Library:Notify("Error: AutoDelete remote not found!", 5)
            return
        end
        
        local currentEgg = Framework.State.selectedDeleteEgg
        
        -- Clear the selection for this egg
        Framework.UI.Options.DeletePetsSelect:SetValue({})
        Framework.State.allDeleteSelections[currentEgg] = {}
        
        -- Re-apply all configurations (which now excludes the cleared egg)
        applyAllAutoDeletes()
        
        Framework.UI.Library:Notify("Cleared auto-delete for " .. currentEgg, 2)
    end,
    Tooltip = "Clear auto-delete settings for the currently selected egg only"
})

AutoDeleteBox:AddButton({
    Text = "Clear All Eggs",
    Func = function()
        if not Framework.Remotes.autoDelete then
            Framework.UI.Library:Notify("Error: AutoDelete remote not found!", 5)
            return
        end
        
        local clearedCount = 0
        for eggName, selections in pairs(Framework.State.allDeleteSelections) do
            if next(selections) then
                clearedCount = clearedCount + 1
            end
        end
        
        if next(Framework.State.globalDeleteRarities) then
            clearedCount = clearedCount + 1
        end
        
        -- Clear all state
        Framework.State.allDeleteSelections = {}
        Framework.State.globalDeleteRarities = {}
        Framework.State.globalDeleteMultiplierThreshold = 0
        
        -- Clear current dropdowns
        Framework.UI.Options.DeletePetsSelect:SetValue({})
        Framework.UI.Options.GlobalDeleteRarities:SetValue({})
        Framework.UI.Options.GlobalDeleteMultiplier:SetValue("0")
        
        -- Send empty configuration to server
        local success = pcall(function()
            Framework.Remotes.autoDelete:FireServer({})
        end)
        
        if success and clearedCount > 0 then
            Framework.UI.Library:Notify("Cleared auto-delete for " .. clearedCount .. " setting(s)", 3)
        else
            Framework.UI.Library:Notify("No auto-delete settings to clear", 2)
        end
    end,
    Tooltip = "Clear auto-delete settings for ALL eggs AND global rarity filter",
    DoubleClick = true
})

    -- Golden Crafting
    GoldenCraftBox:AddDropdown("GoldenCraftAmount", {
        Values = {"1 (5% chance)", "2 (15% chance)", "3 (35% chance)", "4 (60% chance)", "5 (80% chance)", "6 (100% chance)"},
        Default = 6,
        Multi = false,
        Text = "Pets Per Craft",
        Tooltip = "Number of pets to use (more = higher success rate)",
        Callback = function(Value)
            Framework.State.goldenCraftAmount = tonumber(string.match(Value, "^(%d+)"))
            Framework.UI.Library:Notify("Golden craft amount: " .. Framework.State.goldenCraftAmount, 2)
        end
    })
    
    GoldenCraftBox:AddDropdown("GoldenSortMethod", {
    Values = {"Multiplier (Low to High)", "Multiplier (High to Low)", "Owned (High to Low)", "Owned (Low to High)"},
    Default = 1,
    Multi = false,
    Text = "Sort By",
    Tooltip = "Change how pets are sorted in the list",
    Callback = function(Value)
        Framework.State.goldenPetSortMethod = Value
        
        Framework:GetModule("Cache"):Invalidate("allGamePets")
        Framework:GetModule("Cache"):Invalidate("ownedPetCounts")
        
        task.wait(0.1)
        local allPets = Framework:GetModule("PetManagement"):GetAllPetsFromGame()
        
        -- Filter out excluded rarities
        local filteredPets = {}
        for _, petData in ipairs(allPets) do
            if not Framework.State.excludedGoldenRarities[petData.rarity] then
                table.insert(filteredPets, petData)
            end
        end
        
        local sortedPets = Framework:GetModule("PetManagement"):SortPetList(filteredPets, Framework.State.goldenPetSortMethod, "Normal")
        local displayList = {}
        for _, petData in ipairs(sortedPets) do
            if Value == "Multiplier (Low to High)" or Value == "Multiplier (High to Low)" then
                table.insert(displayList, petData.name .. " (" .. Framework:GetModule("Format"):FormatNumber(petData.multiplier) .. "x)")
            else
                table.insert(displayList, petData.name .. " (x" .. petData.normalCount .. " Normal)")
            end
        end
        
        Framework.UI.Options.GoldenPetSelect:SetValues(#displayList > 0 and displayList or {"No pets available"})
        Framework.UI.Library:Notify("Sorted by: " .. Value, 2)
    end
})
    
GoldenCraftBox:AddDropdown("GoldenPetSelect", {
    Values = (function()
        local allPets = Framework:GetModule("PetManagement"):GetAllPetsFromGame()
        local sortedPets = Framework:GetModule("PetManagement"):SortPetList(allPets, Framework.State.goldenPetSortMethod, "Normal")
        local displayList = {}
        for _, petData in ipairs(sortedPets) do
            table.insert(displayList, petData.name .. " (" .. Framework:GetModule("Format"):FormatNumber(petData.multiplier) .. "x)")
        end
        return #displayList > 0 and displayList or {"No pets available"}
    end)(),
    Default = {},
    Multi = true,
    Text = "Select Normal Pets",
    Tooltip = "Choose which NORMAL pets to craft into golden (multi-select) - Type to search!",
    Searchable = true,
    AllowNull = true,
    SpecialType = "Custom",
    Callback = function(Value)
        Framework.State.selectedGoldenPets = {}
        for displayString, _ in pairs(Value) do
            local petName = string.match(displayString, "^(.-)%s*%(x%d+ Normal%)") or 
                           string.match(displayString, "^(.-)%s*%(.-%)$")
            if petName then
                petName = string.match(petName, "^(.-)%s*$") or petName
                table.insert(Framework.State.selectedGoldenPets, petName)
            end
        end
        
        -- Only notify if Auto Smart Select is NOT active (manual selection)
        if not Framework.State.autoSmartSelectGolden then
            local count = 0
            for _ in pairs(Value) do count = count + 1 end
            Framework.UI.Library:Notify("Selected " .. count .. " NORMAL pet type(s) for golden crafting", 2)
        end
    end
})
    
    local goldenRefreshTask = task.spawn(function()
    while getgenv().TapSimLoaded do
        task.wait(3)
        if Framework.UI.Options.GoldenPetSelect then
            Framework:GetModule("Cache"):Invalidate("allGamePets")
            Framework:GetModule("Cache"):Invalidate("ownedPetCounts")
            local allPets = Framework:GetModule("PetManagement"):GetAllPetsFromGame()
            
            -- Filter out excluded rarities
            local filteredPets = {}
            for _, petData in ipairs(allPets) do
                if not Framework.State.excludedGoldenRarities[petData.rarity] then
                    table.insert(filteredPets, petData)
                end
            end
            
            local sortedPets = Framework:GetModule("PetManagement"):SortPetList(filteredPets, Framework.State.goldenPetSortMethod, "Normal")
                local displayList = {}
                
                for _, petData in ipairs(sortedPets) do
                    if Framework.State.goldenPetSortMethod == "Multiplier (Low to High)" or Framework.State.goldenPetSortMethod == "Multiplier (High to Low)" then
                        table.insert(displayList, petData.name .. " (" .. Framework:GetModule("Format"):FormatNumber(petData.multiplier) .. "x)")
                    else
                        table.insert(displayList, petData.name .. " (x" .. petData.normalCount .. " Normal)")
                    end
                end
                
                Framework.UI.Options.GoldenPetSelect:SetValues(#displayList > 0 and displayList or {"No pets available"})
            end
        end
    end)

Framework:AddTask("GoldenPetListRefresh", goldenRefreshTask)
    
    GoldenCraftBox:AddDropdown("GoldenExcludeRarities", {
    Values = (function()
        local rarities = Framework:GetModule("DataLoader"):GetAllRarities()
        return #rarities > 0 and rarities or {"Common", "Rare", "Epic"}
    end)(),
    Default = {},
    Multi = true,
    Text = "Exclude Rarities",
    Tooltip = "Select rarities to exclude from Golden crafting (multi-select)",
    Callback = function(Value)
        Framework.State.excludedGoldenRarities = Value
        local count = 0
        for _ in pairs(Value) do count = count + 1 end
        
        if count > 0 then
            Framework.UI.Library:Notify("Excluding " .. count .. " rarity/rarities from Golden crafting", 2)
        else
            Framework.UI.Library:Notify("No rarities excluded from Golden crafting", 2)
        end
        
        -- Refresh the pet list
        Framework:GetModule("Cache"):Invalidate("allGamePets")
        Framework:GetModule("Cache"):Invalidate("ownedPetCounts")
        
        task.wait(0.1)
        local allPets = Framework:GetModule("PetManagement"):GetAllPetsFromGame()
        
        -- Filter out excluded rarities
        local filteredPets = {}
        for _, petData in ipairs(allPets) do
            if not Framework.State.excludedGoldenRarities[petData.rarity] then
                table.insert(filteredPets, petData)
            end
        end
        
        local sortedPets = Framework:GetModule("PetManagement"):SortPetList(filteredPets, Framework.State.goldenPetSortMethod, "Normal")
        local displayList = {}
        for _, petData in ipairs(sortedPets) do
            if Framework.State.goldenPetSortMethod == "Multiplier (Low to High)" or Framework.State.goldenPetSortMethod == "Multiplier (High to Low)" then
                table.insert(displayList, petData.name .. " (" .. Framework:GetModule("Format"):FormatNumber(petData.multiplier) .. "x)")
            else
                table.insert(displayList, petData.name .. " (x" .. petData.normalCount .. " Normal)")
            end
        end
        
        Framework.UI.Options.GoldenPetSelect:SetValues(#displayList > 0 and displayList or {"No pets available"})
        Framework.UI.Options.GoldenPetSelect:SetValue({})
        Framework.State.selectedGoldenPets = {}
    end
})

    GoldenCraftBox:AddToggle("AutoSmartSelectGolden", {
        Text = "Auto Smart Select",
        Default = false,
        Tooltip = "Automatically keeps selecting all craftable NORMAL pets (updates every 3 seconds)",
        Callback = function(Value)
            Framework.State.autoSmartSelectGolden = Value
            if Value then
                Framework.State.goldenPetSortMethod = "Owned (High to Low)"
                Framework.UI.Options.GoldenSortMethod:SetValue("Owned (High to Low)")
                
                Framework.UI.Library:Notify("Auto Smart Select (Golden) started", 2)
                
                task.spawn(function()
                    local lastSelectedCount = -1 -- Track selection changes
                    
                    while Framework.State.autoSmartSelectGolden do
                        if not Framework.State.autoSmartSelectGolden then break end
                        
                        if Framework.State.goldenPetSortMethod ~= "Owned (High to Low)" then
                            Framework.State.goldenPetSortMethod = "Owned (High to Low)"
                            Framework.UI.Options.GoldenSortMethod:SetValue("Owned (High to Low)")
                        end
                        
                        Framework:GetModule("Cache"):Invalidate("allGamePets")
                        Framework:GetModule("Cache"):Invalidate("ownedPetCounts")
                        
                        local allPets = Framework:GetModule("PetManagement"):GetAllPetsFromGame()
                        
                        -- Filter out excluded rarities
                        local filteredPets = {}
                        for _, petData in ipairs(allPets) do
                            if not Framework.State.excludedGoldenRarities[petData.rarity] then
                                table.insert(filteredPets, petData)
                            end
                        end
                        
                        local sortedPets = Framework:GetModule("PetManagement"):SortPetList(filteredPets, Framework.State.goldenPetSortMethod, "Normal")
                        local displayList = {}
                        for _, petData in ipairs(sortedPets) do
                            table.insert(displayList, petData.name .. " (x" .. petData.normalCount .. " Normal)")
                        end
                        
                        Framework.UI.Options.GoldenPetSelect:SetValues(displayList)
                        
                        local selectionDict = {}
                        local craftableCount = 0
                        
                        for _, displayString in ipairs(displayList) do
                            local count = tonumber(string.match(displayString, "%(x(%d+) Normal%)"))
                            
                            if count and count >= Framework.State.goldenCraftAmount then
                                selectionDict[displayString] = true
                                craftableCount = craftableCount + 1
                            end
                        end
                        
                        Framework.UI.Options.GoldenPetSelect:SetValue(selectionDict)
                        
                        -- Only notify if selection count actually changed
                        if craftableCount ~= lastSelectedCount then
                            lastSelectedCount = craftableCount
                            if Framework.UI.Toggles.ShowNotifications and Framework.UI.Toggles.ShowNotifications.Value then
                                if craftableCount > 0 then
                                    Framework.UI.Library:Notify("‚úì Golden: " .. craftableCount .. " pet type(s) ready", 2)
                                end
                            end
                        end
                        
                        task.wait(3)
                    end
                end)
            else
                Framework.UI.Library:Notify("Auto Smart Select (Golden) stopped", 2)
            end
        end
    })
    
    GoldenCraftBox:AddButton({
        Text = "Clear Selection",
        Func = function()
            Framework.UI.Options.GoldenPetSelect:SetValue({})
            Framework.State.selectedGoldenPets = {}
            Framework.UI.Library:Notify("Selection cleared", 2)
        end,
        Tooltip = "Clear all selected pets"
    })
    
    GoldenCraftBox:AddDivider()
    
    GoldenCraftBox:AddButton({
        Text = "Teleport to Golden Machine",
        Func = function()
            Framework:GetModule("Teleport"):TeleportToMachine("Golden")
        end,
        Tooltip = "Teleport to Golden Machine (searches all zones if needed)"
    })
    
    GoldenCraftBox:AddButton({
        Text = "Clear Saved Golden Location",
        Func = function()
            Framework:GetModule("Teleport"):ClearSavedLocation("Golden")
        end,
        Tooltip = "Clear the saved Golden Machine location to search again"
    })
    
    GoldenCraftBox:AddLabel("Machine Location Info:")
    Framework.UI.Labels.goldenLocation = GoldenCraftBox:AddLabel("Saved: None")
    
    UIUpdateManager:Register("goldenLocation", function()
        if Framework.State.savedGoldenMachinePosition then
            Framework.UI.Labels.goldenLocation:SetText("Saved: " .. Framework.State.savedGoldenIslandMultiplier .. "x multiplier zone")
        else
            Framework.UI.Labels.goldenLocation:SetText("Saved: None (will search on next use)")
        end
    end)
    
    GoldenCraftBox:AddToggle("AutoCraftGolden", {
        Text = "Auto Craft Golden",
        Default = false,
        Tooltip = "Automatically craft selected pets into golden pets",
        Callback = function(Value)
            if Value then
                Framework:GetModule("AutoCraftGolden"):Start()
            else
                Framework:GetModule("AutoCraftGolden"):Stop()
            end
        end
    })
    
    -- Rainbow Crafting
    RainbowCraftBox:AddDropdown("RainbowCraftAmount", {
        Values = {"1 (8 hours)", "2 (5 hours)", "3 (2h 30m)", "4 (1 hour)", "5 (30 seconds)"},
        Default = 5,
        Multi = false,
        Text = "Pets Per Craft",
        Tooltip = "Number of golden pets to use (less wait time with more pets)",
        Callback = function(Value)
            Framework.State.rainbowCraftAmount = tonumber(string.match(Value, "^(%d+)"))
            Framework.UI.Library:Notify("Rainbow craft amount: " .. Framework.State.rainbowCraftAmount, 2)
        end
    })

    RainbowCraftBox:AddDropdown("RainbowSortMethod", {
    Values = {"Multiplier (Low to High)", "Multiplier (High to Low)", "Owned (High to Low)", "Owned (Low to High)"},
    Default = 1,
    Multi = false,
    Text = "Sort By",
    Tooltip = "Change how pets are sorted in the list",
    Callback = function(Value)
        Framework.State.rainbowPetSortMethod = Value
        
        Framework:GetModule("Cache"):Invalidate("allGamePets")
        Framework:GetModule("Cache"):Invalidate("ownedPetCounts")
        
        task.wait(0.1)
        local allPets = Framework:GetModule("PetManagement"):GetAllPetsFromGame()
        
        -- Filter out excluded rarities
        local filteredPets = {}
        for _, petData in ipairs(allPets) do
            if not Framework.State.excludedRainbowRarities[petData.rarity] then
                table.insert(filteredPets, petData)
            end
        end
        
        local sortedPets = Framework:GetModule("PetManagement"):SortPetList(filteredPets, Framework.State.rainbowPetSortMethod, "Golden")
        local displayList = {}
        for _, petData in ipairs(sortedPets) do
            if Value == "Multiplier (Low to High)" or Value == "Multiplier (High to Low)" then
                table.insert(displayList, petData.name .. " (" .. Framework:GetModule("Format"):FormatNumber(petData.multiplier) .. "x)")
            else
                table.insert(displayList, petData.name .. " (x" .. petData.goldenCount .. " Golden)")
            end
        end
        
        Framework.UI.Options.RainbowPetSelect:SetValues(#displayList > 0 and displayList or {"No pets available"})
        Framework.UI.Library:Notify("Sorted by: " .. Value, 2)
    end
})
    
    RainbowCraftBox:AddDropdown("RainbowPetSelect", {
        Values = (function()
            local allPets = Framework:GetModule("PetManagement"):GetAllPetsFromGame()
            local sortedPets = Framework:GetModule("PetManagement"):SortPetList(allPets, Framework.State.rainbowPetSortMethod, "Golden")
            local displayList = {}
            for _, petData in ipairs(sortedPets) do
                table.insert(displayList, petData.name .. " (" .. Framework:GetModule("Format"):FormatNumber(petData.multiplier) .. "x)")
            end
            return #displayList > 0 and displayList or {"No pets available"}
        end)(),
        Default = {},
        Multi = true,
        Text = "Select Golden Pets",
        Tooltip = "Choose which GOLDEN pets to craft into rainbow (multi-select) - Type to search!",
        Searchable = true,
        AllowNull = true,
        SpecialType = "Custom",
        Callback = function(Value)
            Framework.State.selectedRainbowPets = {}
            for displayString, _ in pairs(Value) do
                local petName = string.match(displayString, "^(.-)%s*%(x%d+ Golden%)") or
                               string.match(displayString, "^(.-)%s*%(")
                if petName then
                    table.insert(Framework.State.selectedRainbowPets, petName)
                end
            end
            
            -- Only notify if Auto Smart Select is NOT active (manual selection)
            if not Framework.State.autoSmartSelectRainbow then
                local count = 0
                for _ in pairs(Value) do count = count + 1 end
                Framework.UI.Library:Notify("Selected " .. count .. " GOLDEN pet type(s) for rainbow crafting", 2)
            end
        end
    })
    
   local rainbowRefreshTask = task.spawn(function()
    while getgenv().TapSimLoaded do
        task.wait(3) -- Increased from 2 to 3 seconds
        if Framework.UI.Options.RainbowPetSelect then
            Framework:GetModule("Cache"):Invalidate("allGamePets")
            local allPets = Framework:GetModule("PetManagement"):GetAllPetsFromGame()
            
            -- Filter out excluded rarities
            local filteredPets = {}
            for _, petData in ipairs(allPets) do
                if not Framework.State.excludedRainbowRarities[petData.rarity] then
                    table.insert(filteredPets, petData)
                end
            end
            
            local sortedPets = Framework:GetModule("PetManagement"):SortPetList(filteredPets, Framework.State.rainbowPetSortMethod, "Golden")
                local displayList = {}
                
                for _, petData in ipairs(sortedPets) do
                    if Framework.State.rainbowPetSortMethod == "Multiplier (Low to High)" or Framework.State.rainbowPetSortMethod == "Multiplier (High to Low)" then
                        table.insert(displayList, petData.name .. " (" .. Framework:GetModule("Format"):FormatNumber(petData.multiplier) .. "x)")
                    else
                        table.insert(displayList, petData.name .. " (x" .. petData.goldenCount .. " Golden)")
                    end
                end
                
                Framework.UI.Options.RainbowPetSelect:SetValues(#displayList > 0 and displayList or {"No pets available"})
            end
    end
end)

Framework:AddTask("RainbowPetListRefresh", rainbowRefreshTask)
    
    RainbowCraftBox:AddDropdown("RainbowExcludeRarities", {
    Values = (function()
        local rarities = Framework:GetModule("DataLoader"):GetAllRarities()
        return #rarities > 0 and rarities or {"Common", "Rare", "Epic"}
    end)(),
    Default = {},
    Multi = true,
    Text = "Exclude Rarities",
    Tooltip = "Select rarities to exclude from Rainbow crafting (multi-select)",
    Callback = function(Value)
        Framework.State.excludedRainbowRarities = Value
        local count = 0
        for _ in pairs(Value) do count = count + 1 end
        
        if count > 0 then
            Framework.UI.Library:Notify("Excluding " .. count .. " rarity/rarities from Rainbow crafting", 2)
        else
            Framework.UI.Library:Notify("No rarities excluded from Rainbow crafting", 2)
        end
        
        -- Refresh the pet list
        Framework:GetModule("Cache"):Invalidate("allGamePets")
        Framework:GetModule("Cache"):Invalidate("ownedPetCounts")
        
        task.wait(0.1)
        local allPets = Framework:GetModule("PetManagement"):GetAllPetsFromGame()
        
        -- Filter out excluded rarities
        local filteredPets = {}
        for _, petData in ipairs(allPets) do
            if not Framework.State.excludedRainbowRarities[petData.rarity] then
                table.insert(filteredPets, petData)
            end
        end
        
        local sortedPets = Framework:GetModule("PetManagement"):SortPetList(filteredPets, Framework.State.rainbowPetSortMethod, "Golden")
        local displayList = {}
        for _, petData in ipairs(sortedPets) do
            if Framework.State.rainbowPetSortMethod == "Multiplier (Low to High)" or Framework.State.rainbowPetSortMethod == "Multiplier (High to Low)" then
                table.insert(displayList, petData.name .. " (" .. Framework:GetModule("Format"):FormatNumber(petData.multiplier) .. "x)")
            else
                table.insert(displayList, petData.name .. " (x" .. petData.goldenCount .. " Golden)")
            end
        end
        
        Framework.UI.Options.RainbowPetSelect:SetValues(#displayList > 0 and displayList or {"No pets available"})
        Framework.UI.Options.RainbowPetSelect:SetValue({})
        Framework.State.selectedRainbowPets = {}
    end
})

    RainbowCraftBox:AddToggle("AutoSmartSelectRainbow", {
        Text = "Auto Smart Select",
        Default = false,
        Tooltip = "Automatically keeps selecting all craftable GOLDEN pets (updates every 3 seconds)",
        Callback = function(Value)
            Framework.State.autoSmartSelectRainbow = Value
            if Value then
                Framework.State.rainbowPetSortMethod = "Owned (High to Low)"
                Framework.UI.Options.RainbowSortMethod:SetValue("Owned (High to Low)")
                
                Framework.UI.Library:Notify("Auto Smart Select (Rainbow) started", 2)
                
                task.spawn(function()
                    local lastSelectedCount = -1 -- Track selection changes
                    
                    while Framework.State.autoSmartSelectRainbow do
                        if not Framework.State.autoSmartSelectRainbow then break end
                        
                        if Framework.State.rainbowPetSortMethod ~= "Owned (High to Low)" then
                            Framework.State.rainbowPetSortMethod = "Owned (High to Low)"
                            Framework.UI.Options.RainbowSortMethod:SetValue("Owned (High to Low)")
                        end
                        
                        Framework:GetModule("Cache"):Invalidate("allGamePets")
                        Framework:GetModule("Cache"):Invalidate("ownedPetCounts")
                        
                        local allPets = Framework:GetModule("PetManagement"):GetAllPetsFromGame()
                        
                        -- Filter out excluded rarities
                        local filteredPets = {}
                        for _, petData in ipairs(allPets) do
                            if not Framework.State.excludedRainbowRarities[petData.rarity] then
                                table.insert(filteredPets, petData)
                            end
                        end
                        
                        local sortedPets = Framework:GetModule("PetManagement"):SortPetList(filteredPets, Framework.State.rainbowPetSortMethod, "Golden")
                        local displayList = {}
                        for _, petData in ipairs(sortedPets) do
                            table.insert(displayList, petData.name .. " (x" .. petData.goldenCount .. " Golden)")
                        end
                        
                        Framework.UI.Options.RainbowPetSelect:SetValues(displayList)
                        
                        local selectionDict = {}
                        local craftableCount = 0
                        
                        for _, displayString in ipairs(displayList) do
                            local count = tonumber(string.match(displayString, "%(x(%d+) Golden%)"))
                            
                            if count and count >= Framework.State.rainbowCraftAmount then
                                selectionDict[displayString] = true
                                craftableCount = craftableCount + 1
                            end
                        end
                        
                        Framework.UI.Options.RainbowPetSelect:SetValue(selectionDict)
                        
                        -- Only notify if selection count actually changed
                        if craftableCount ~= lastSelectedCount then
                            lastSelectedCount = craftableCount
                            if Framework.UI.Toggles.ShowNotifications and Framework.UI.Toggles.ShowNotifications.Value then
                                if craftableCount > 0 then
                                    Framework.UI.Library:Notify("‚úì Rainbow: " .. craftableCount .. " pet type(s) ready", 2)
                                end
                            end
                        end
                        
                        task.wait(3)
                    end
                end)
            else
                Framework.UI.Library:Notify("Auto Smart Select (Rainbow) stopped", 2)
            end
        end
    })
    
    RainbowCraftBox:AddButton({
        Text = "Clear Selection",
        Func = function()
            Framework.UI.Options.RainbowPetSelect:SetValue({})
            Framework.State.selectedRainbowPets = {}
            Framework.UI.Library:Notify("Selection cleared", 2)
        end,
        Tooltip = "Clear all selected pets"
    })
    
    RainbowCraftBox:AddDivider()
    
    RainbowCraftBox:AddButton({
        Text = "Teleport to Rainbow Machine",
        Func = function()
            Framework:GetModule("Teleport"):TeleportToMachine("Rainbow")
        end,
        Tooltip = "Teleport to Rainbow Machine (searches all zones if needed)"
    })
    
    RainbowCraftBox:AddButton({
        Text = "Clear Saved Rainbow Location",
        Func = function()
            Framework:GetModule("Teleport"):ClearSavedLocation("Rainbow")
        end,
        Tooltip = "Clear the saved Rainbow Machine location to search again"
    })
    
    RainbowCraftBox:AddLabel("Machine Location Info:")
    Framework.UI.Labels.rainbowLocation = RainbowCraftBox:AddLabel("Saved: None")
    
    UIUpdateManager:Register("rainbowLocation", function()
        if Framework.State.savedRainbowMachinePosition then
            Framework.UI.Labels.rainbowLocation:SetText("Saved: " .. Framework.State.savedRainbowIslandMultiplier .. "x multiplier zone")
        else
            Framework.UI.Labels.rainbowLocation:SetText("Saved: None (will search on next use)")
        end
    end)
    
    RainbowCraftBox:AddDivider()
    
    RainbowCraftBox:AddToggle("AutoCraftRainbow", {
        Text = "Auto Craft Rainbow",
        Default = false,
        Tooltip = "Automatically craft golden pets into rainbow pets",
        Callback = function(Value)
            if Value then
                Framework:GetModule("AutoCraftRainbow"):Start()
            else
                Framework:GetModule("AutoCraftRainbow"):Stop()
            end
        end
    })
    
    -- Rainbow Status Box
    RainbowStatusBox:AddLabel("Rainbow Machine Status")
    RainbowStatusBox:AddDivider()
    
    Framework.UI.Labels.rainbowSlot1 = RainbowStatusBox:AddLabel("Slot 1: Empty")
    Framework.UI.Labels.rainbowSlot2 = RainbowStatusBox:AddLabel("Slot 2: Empty")
    Framework.UI.Labels.rainbowSlot3 = RainbowStatusBox:AddLabel("Slot 3: Empty")
    RainbowStatusBox:AddDivider()
    Framework.UI.Labels.rainbowReadyCount = RainbowStatusBox:AddLabel("Ready to Claim: 0/3")
    
    UIUpdateManager:Register("rainbowStatus", function()
        if not Framework.Data.replicationData or not Framework.Data.replicationData.Data or not Framework.Data.replicationData.Data.CraftingPets then
            for i = 1, 3 do
                Framework.UI.Labels["rainbowSlot" .. i]:SetText("Slot " .. i .. ": Empty")
            end
            Framework.UI.Labels.rainbowReadyCount:SetText("Ready to Claim: 0/3")
            return
        end
        
        local rainbowPets = Framework.Data.replicationData.Data.CraftingPets.Rainbow
        
        if not rainbowPets then
            for i = 1, 3 do
                Framework.UI.Labels["rainbowSlot" .. i]:SetText("Slot " .. i .. ": Empty")
            end
            Framework.UI.Labels.rainbowReadyCount:SetText("Ready to Claim: 0/3")
            return
        end
        
        local serverTime = workspace:GetServerTimeNow()
        local readyCount = 0
        local slotData = {}
        
        for petId, petData in pairs(rainbowPets) do
            local timeRemaining = math.max(0, petData.EndTime - serverTime)
            local isReady = timeRemaining <= 0
            
            if isReady then
                readyCount = readyCount + 1
            end
            
            table.insert(slotData, {
                name = petData.Name,
                timeRemaining = timeRemaining,
                isReady = isReady
            })
        end
        
        table.sort(slotData, function(a, b)
            if a.isReady ~= b.isReady then
                return a.isReady
            end
            return a.timeRemaining < b.timeRemaining
        end)
        
        for i = 1, 3 do
            if slotData[i] then
                local timeRemaining = slotData[i].timeRemaining
                
                if slotData[i].isReady then
                    Framework.UI.Labels["rainbowSlot" .. i]:SetText("Slot " .. i .. ": " .. slotData[i].name .. " - READY!")
                else
                    local displayTime = ""
                    if timeRemaining >= 3600 then
                        local hours = math.floor(timeRemaining / 3600)
                        local mins = math.floor((timeRemaining % 3600) / 60)
                        displayTime = hours .. "h " .. mins .. "m"
                    elseif timeRemaining >= 60 then
                        local mins = math.floor(timeRemaining / 60)
                        local secs = math.floor(timeRemaining % 60)
                        displayTime = mins .. "m " .. secs .. "s"
                    else
                        displayTime = math.floor(timeRemaining) .. "s"
                    end
                    
                    Framework.UI.Labels["rainbowSlot" .. i]:SetText("Slot " .. i .. ": " .. slotData[i].name .. " - " .. displayTime)
                end
            else
                Framework.UI.Labels["rainbowSlot" .. i]:SetText("Slot " .. i .. ": Empty")
            end
        end
        
        Framework.UI.Labels.rainbowReadyCount:SetText("Ready to Claim: " .. readyCount .. "/3")
    end)
    
    RainbowStatusBox:AddToggle("AutoClaimRainbow", {
        Text = "Auto Claim Rainbow Pets",
        Default = false,
        Tooltip = "Automatically claim rainbow pets when ready",
        Callback = function(Value)
            if Value then
                Framework:GetModule("AutoClaimRainbow"):Start()
            else
                Framework:GetModule("AutoClaimRainbow"):Stop()
            end
        end
    })
    
    -- ==================== ENCHANTING TAB ====================
local EnchantingTab = Framework.UI.Tabs.Enchanting
local EnchantBox = EnchantingTab:AddLeftGroupbox("Auto Enchant")
local EnchantInfoBox = EnchantingTab:AddRightGroupbox("Enchant Info")
local CrystalBox = EnchantingTab:AddLeftGroupbox("Crystal Management")

-- Priority and settings
EnchantBox:AddDropdown("EnchantPriorityMode", {
    Values = {"Multiplier (Low to High)", "Multiplier (High to Low)", "Rarity (Low to High)", "Rarity (High to Low)"},
    Default = 1,
    Multi = false,
    Text = "Enchant Priority",
    Tooltip = "Order in which pets are enchanted",
    Callback = function(Value)
        Framework.State.enchantPriorityMode = Value
        Framework.UI.Library:Notify("Enchant priority: " .. Value, 2)
    end
})

EnchantBox:AddToggle("KeepBestEnchant", {
    Text = "Keep Best Enchant",
    Default = true,
    Tooltip = "Don't re-enchant if current enchant is equal or better than target",
    Callback = function(Value)
        Framework.State.keepBestEnchant = Value
        if Value then
            Framework.UI.Library:Notify("Will keep enchants equal or better than target", 2)
        else
            Framework.UI.Library:Notify("Will always re-enchant to exact target", 2)
        end
    end
})

-- Target enchant selection
EnchantBox:AddDropdown("EnchantTypeSelect", {
    Values = (function()
        if not Framework.Data.enchantList or #Framework.Data.enchantList == 0 then
            return {"Loading enchants..."}
        end
        
        local displayList = {}
        for _, enchantData in ipairs(Framework.Data.enchantList) do
            table.insert(displayList, enchantData.display)
        end
        return displayList
    end)(),
    Default = {},
    Multi = true,
    Text = "Target Enchant(s)",
    Tooltip = "Select which enchant(s) you want to roll for (multi-select)",
    Callback = function(Value)
        Framework.State.selectedEnchantTypes = Value
        
        local count = 0
        local enchantNames = {}
        for enchantName, _ in pairs(Value) do
            count = count + 1
            local cleanName = string.match(enchantName, "^(.-)%s*%(") or enchantName
            table.insert(enchantNames, cleanName)
        end
        
        if count > 0 then
            Framework.UI.Library:Notify("Target enchants: " .. table.concat(enchantNames, ", "), 2)
        else
            Framework.UI.Library:Notify("No target enchants selected", 2)
        end
    end
})

EnchantBox:AddDivider()

-- Helper function to refresh the enchant pet list dropdown
local function refreshEnchantPetList()
    if not Framework.UI.Options.EnchantPetSelect then return end
    
    Framework:GetModule("Cache"):Invalidate("allGamePets")
    Framework:GetModule("Cache"):Invalidate("ownedPetCounts")
    
    task.wait(0.1)
    
    local petList = getEnchantablePets(Framework.State.enchantPetSortMethod, Framework.State.showIndividualPetsEnchant)
    
    local displayValues = {}
    for _, pet in ipairs(petList) do
        table.insert(displayValues, pet.display)
    end
    
    -- Update dropdown values
    Framework.UI.Options.EnchantPetSelect:SetValues(#displayValues > 0 and displayValues or {"No pets available"})
end

-- Add this BEFORE the "Exclude Rarities" dropdown in EnchantBox
EnchantBox:AddToggle("ShowIndividualPetsEnchant", {
    Text = "Show Individual Pet Instances",
    Default = false,
    Tooltip = "When enabled, shows each pet separately (with ID) instead of grouping by name",
    Callback = function(Value)
        Framework.State.showIndividualPetsEnchant = Value
        
        -- Refresh the pet list immediately
        Framework:GetModule("Cache"):Invalidate("allGamePets")
        Framework:GetModule("Cache"):Invalidate("ownedPetCounts")
        
        task.wait(0.1)
        local petList = getEnchantablePets(Framework.State.enchantPetSortMethod, Value)
        
        local displayValues = {}
        for _, pet in ipairs(petList) do
            table.insert(displayValues, pet.display)
        end
        
        Framework.UI.Options.EnchantPetSelect:SetValues(displayValues)
        Framework.UI.Options.EnchantPetSelect:SetValue({})
        Framework.State.selectedEnchantPets = {}
        
        if Value then
            Framework.UI.Library:Notify("Now showing individual pet instances", 2)
        else
            Framework.UI.Library:Notify("Now showing grouped pets by name", 2)
        end
    end
})

-- Rarity exclusion dropdown
EnchantBox:AddDropdown("EnchantExcludeRarities", {
    Values = (function()
        local rarities = Framework:GetModule("DataLoader"):GetAllRarities()
        return #rarities > 0 and rarities or {"Common", "Rare", "Epic"}
    end)(),
    Default = {},
    Multi = true,
    Text = "Exclude Rarities",
    Tooltip = "Select rarities to exclude from enchanting (multi-select)",
    Callback = function(Value)
        Framework.State.excludedEnchantRarities = Value
        local count = 0
        for _ in pairs(Value) do count = count + 1 end
        
        if count > 0 then
            Framework.UI.Library:Notify("Excluding " .. count .. " rarity/rarities from enchanting", 2)
        else
            Framework.UI.Library:Notify("No rarities excluded from enchanting", 2)
        end
        
        -- Refresh the pet list
        Framework:GetModule("Cache"):Invalidate("allGamePets")
        Framework:GetModule("Cache"):Invalidate("ownedPetCounts")
        
        task.wait(0.1)
        local petList = getEnchantablePets(Framework.State.enchantPetSortMethod, Framework.State.showIndividualPetsEnchant)
        
        local displayValues = {}
        for _, pet in ipairs(petList) do
            table.insert(displayValues, pet.display)
        end
        
        Framework.UI.Options.EnchantPetSelect:SetValues(displayValues)
        Framework.UI.Options.EnchantPetSelect:SetValue({})
        Framework.State.selectedEnchantPets = {}
    end
})

EnchantBox:AddToggle("ExcludeEquippedEnchant", {
    Text = "Exclude Equipped Pets",
    Default = false,
    Tooltip = "Only show unequipped pets in the list",
    Callback = function(Value)
        Framework.State.excludeEquippedEnchant = Value
        
        -- Refresh the pet list
        Framework:GetModule("Cache"):Invalidate("allGamePets")
        Framework:GetModule("Cache"):Invalidate("ownedPetCounts")
        
        task.wait(0.1)
        local petList = getEnchantablePets(Framework.State.enchantPetSortMethod, Framework.State.showIndividualPetsEnchant)
        
        local displayValues = {}
        for _, pet in ipairs(petList) do
            table.insert(displayValues, pet.display)
        end
        
        Framework.UI.Options.EnchantPetSelect:SetValues(displayValues)
        Framework.UI.Options.EnchantPetSelect:SetValue({})
        Framework.State.selectedEnchantPets = {}
        
        if Value then
            Framework.UI.Library:Notify("Now showing only unequipped pets", 2)
        else
            Framework.UI.Library:Notify("Now showing all pets", 2)
        end
    end
})

-- Pet selection dropdown
EnchantBox:AddDropdown("EnchantPetSelect", {
    Values = (function()
        local petList = getEnchantablePets(Framework.State.enchantPetSortMethod, Framework.State.showIndividualPetsEnchant)
        local displayValues = {}
        for _, pet in ipairs(petList) do
            table.insert(displayValues, pet.display)
        end
        return displayValues
    end)(),
    Default = {},
    Multi = true,
    Text = "Select Pet(s)",
    Tooltip = "Choose which pet(s) to enchant - will enchant in queue order (multi-select) - Type to search!",
    Searchable = true,
    AllowNull = true,
    SpecialType = "Custom",
    Callback = function(Value)
        Framework.State.selectedEnchantPets = {}
        
        if Framework.State.showIndividualPetsEnchant then
            -- Individual mode: Extract pet IDs directly from display string
            for displayString, _ in pairs(Value) do
                -- Extract the pet ID from the end of the string (e.g., "#abc123")
                local petIdFragment = string.match(displayString, "#(%w+)$")
                
                if petIdFragment then
                    -- Find the full pet ID that starts with this fragment
                    if Framework.Data.replicationData and Framework.Data.replicationData.Data and Framework.Data.replicationData.Data.Pets then
                        for petId, petData in pairs(Framework.Data.replicationData.Data.Pets) do
                            if string.sub(petId, 1, 6) == petIdFragment then
                                -- Extract pet name for display
                                local petName = string.match(displayString, "^(.-)%s*{?") or 
                                              string.match(displayString, "^(.-)%s*%[?") or
                                              string.match(displayString, "^(.-)%s*%(")
                                
                                table.insert(Framework.State.selectedEnchantPets, {
                                    id = petId,
                                    name = petName or petData.Name
                                })
                                break
                            end
                        end
                    end
                end
            end
        else
            -- Grouped mode: Get all pet IDs for each selected pet name
            for displayString, _ in pairs(Value) do
                -- Extract pet name from display string
                local petName = string.match(displayString, "^(.-)%s*%(") or displayString
                
                -- Get all pet IDs for this pet name from current inventory
                if Framework.Data.replicationData and Framework.Data.replicationData.Data and Framework.Data.replicationData.Data.Pets then
                    for petId, petData in pairs(Framework.Data.replicationData.Data.Pets) do
                        if petData.Name == petName then
                            -- Check if this pet passes filters
                            local petStats = Framework.Data.petStats[petName]
                            local rarity = petStats and petStats.Rarity or "Unknown"
                            
                            -- Skip if rarity excluded or equipped (if filter enabled)
                            if not Framework.State.excludedEnchantRarities[rarity] and 
                               not (Framework.State.excludeEquippedEnchant and petData.Equipped) then
                                table.insert(Framework.State.selectedEnchantPets, {
                                    id = petId,
                                    name = petName
                                })
                            end
                        end
                    end
                end
            end
        end
        
        local count = #Framework.State.selectedEnchantPets
        if count > 0 then
            if Framework.State.showIndividualPetsEnchant then
                Framework.UI.Library:Notify("Selected " .. count .. " specific pet(s) for enchanting", 3)
            else
                -- Count unique pet names for the notification
                local uniquePets = {}
                for _, pet in ipairs(Framework.State.selectedEnchantPets) do
                    uniquePets[pet.name] = true
                end
                local uniqueCount = 0
                for _ in pairs(uniquePets) do uniqueCount = uniqueCount + 1 end
                
                Framework.UI.Library:Notify("Selected " .. count .. " pet instance(s) (" .. uniqueCount .. " unique) for enchanting", 3)
            end
        end
    end
})

-- Auto-refresh enchant pet list
local enchantRefreshTask = task.spawn(function()
    while getgenv().TapSimLoaded do
        task.wait(3)
        if Framework.UI.Options.EnchantPetSelect then
            -- Don't refresh while user is selecting pets
            local currentSelection = Framework.UI.Options.EnchantPetSelect.Value
            local hasSelection = false
            if type(currentSelection) == "table" then
                for _ in pairs(currentSelection) do
                    hasSelection = true
                    break
                end
            end
            
            -- Only refresh if no selection or forced refresh needed
            if not hasSelection then
                Framework:GetModule("Cache"):Invalidate("allGamePets")
                Framework:GetModule("Cache"):Invalidate("ownedPetCounts")
                
                local petList = getEnchantablePets(Framework.State.enchantPetSortMethod, Framework.State.showIndividualPetsEnchant)
                local displayValues = {}
                
                for _, pet in ipairs(petList) do
                    table.insert(displayValues, pet.display)
                end
                
                Framework.UI.Options.EnchantPetSelect:SetValues(#displayValues > 0 and displayValues or {"No pets available"})
            end
        end
    end
end)

Framework:AddTask("EnchantPetListRefresh", enchantRefreshTask)

-- Clear selection button
EnchantBox:AddButton({
    Text = "Clear Selection",
    Func = function()
        Framework.UI.Options.EnchantPetSelect:SetValue({})
        Framework.State.selectedEnchantPets = {}
        Framework.UI.Library:Notify("Pet selection cleared", 2)
    end,
    Tooltip = "Clear all selected pets"
})

EnchantBox:AddDivider()

-- Teleport to enchant machine
EnchantBox:AddButton({
    Text = "Teleport to Enchant Machine",
    Func = function()
        Framework:GetModule("Teleport"):TeleportToMachine("Enchant")
    end,
    Tooltip = "Teleport to Enchant Machine (searches all zones if needed)"
})

EnchantBox:AddButton({
    Text = "Clear Saved Enchant Location",
    Func = function()
        Framework:GetModule("Teleport"):ClearSavedLocation("Enchant")
    end,
    Tooltip = "Clear the saved Enchant Machine location to search again"
})

EnchantBox:AddLabel("Machine Location Info:")
Framework.UI.Labels.enchantLocation = EnchantBox:AddLabel("Saved: None")

UIUpdateManager:Register("enchantLocation", function()
    if Framework.State.savedEnchantMachinePosition then
        Framework.UI.Labels.enchantLocation:SetText("Saved: " .. Framework.State.savedEnchantIslandMultiplier .. "x multiplier zone")
    else
        Framework.UI.Labels.enchantLocation:SetText("Saved: None (will search on next use)")
    end
end)

EnchantBox:AddDivider()

-- Auto enchant toggle
EnchantBox:AddToggle("AutoEnchant", {
    Text = "Auto Enchant",
    Default = false,
    Tooltip = "Automatically enchant the selected pets until target enchant is rolled",
    Callback = function(Value)
        if Value then
            Framework:GetModule("AutoEnchant"):Start()
        else
            Framework:GetModule("AutoEnchant"):Stop()
        end
    end
})
    
    -- ==================== ENCHANT INFO BOX ====================
    
    EnchantInfoBox:AddLabel("Enchant Status")
    EnchantInfoBox:AddDivider()
    
    Framework.UI.Labels.enchantCrystals = EnchantInfoBox:AddLabel("Enchant Crystals: 0")
    Framework.UI.Labels.enchantStatus = EnchantInfoBox:AddLabel("Status: Idle")
    Framework.UI.Labels.currentEnchantingPet = EnchantInfoBox:AddLabel("Current Pet: None")
    Framework.UI.Labels.currentPetEnchant = EnchantInfoBox:AddLabel("Current Enchant: None")
    
    EnchantInfoBox:AddDivider()
    EnchantInfoBox:AddLabel("Queue Info")
    
    Framework.UI.Labels.queueSize = EnchantInfoBox:AddLabel("Pets in Queue: 0")
    Framework.UI.Labels.queueCompleted = EnchantInfoBox:AddLabel("Completed: 0")
    Framework.UI.Labels.totalSpins = EnchantInfoBox:AddLabel("Total Spins: 0")
    
    EnchantInfoBox:AddDivider()
    EnchantInfoBox:AddLabel("Next 3 Pets in Queue:")
    
    Framework.UI.Labels.queuePet1 = EnchantInfoBox:AddLabel("1. None")
    Framework.UI.Labels.queuePet2 = EnchantInfoBox:AddLabel("2. None")
    Framework.UI.Labels.queuePet3 = EnchantInfoBox:AddLabel("3. None")
    
    -- Add after the existing labels in EnchantInfoBox
EnchantInfoBox:AddDivider()
EnchantInfoBox:AddLabel("Connection Info")

Framework.UI.Labels.currentPing = EnchantInfoBox:AddLabel("Ping: 0ms")
Framework.UI.Labels.effectiveDelay = EnchantInfoBox:AddLabel("Effective Delay: 0.30s")
Framework.UI.Labels.failStreak = EnchantInfoBox:AddLabel("Fail Streak: 0")

-- Register ping info updates
UIUpdateManager:Register("enchantPingInfo", function()
    local ping = Framework.PingMonitor.currentPing
    Framework.UI.Labels.currentPing:SetText("Ping: " .. math.floor(ping) .. "ms")
    
    local effectiveDelay = Framework.PingMonitor:GetAdaptiveDelay(Framework.State.enchantSpinDelay)
    Framework.UI.Labels.effectiveDelay:SetText("Effective Delay: " .. string.format("%.2f", effectiveDelay) .. "s")
    
    Framework.UI.Labels.failStreak:SetText("Fail Streak: " .. (Framework.State.enchantFailStreak or 0))
end)

    -- Register info updates
    UIUpdateManager:Register("enchantInfo", function()
        local crystals = Framework:GetModule("AutoEnchant"):GetEnchantCrystals()
        Framework.UI.Labels.enchantCrystals:SetText("Enchant Crystals: " .. Framework:GetModule("Format"):FormatNumber(crystals))
        
        -- Status
        if Framework:GetModule("AutoEnchant").enabled then
            if Framework.State.isCurrentlyFarmingCrystals then
                Framework.UI.Labels.enchantStatus:SetText("Status: Farming Crystals")
            else
                Framework.UI.Labels.enchantStatus:SetText("Status: Enchanting")
            end
        else
            Framework.UI.Labels.enchantStatus:SetText("Status: Idle")
        end
        
        -- Current pet being enchanted
        if Framework.State.selectedEnchantPet then
            pcall(function()
                if Framework.Data.replicationData and Framework.Data.replicationData.Data and Framework.Data.replicationData.Data.Pets then
                    local petData = Framework.Data.replicationData.Data.Pets[Framework.State.selectedEnchantPet]
                    if petData then
                        Framework.UI.Labels.currentEnchantingPet:SetText("Current Pet: " .. petData.Name)
                        
                        local enchant = Framework:GetModule("AutoEnchant"):GetCurrentEnchant(Framework.State.selectedEnchantPet)
                        if enchant then
                            Framework.UI.Labels.currentPetEnchant:SetText("Current Enchant: " .. enchant)
                        else
                            Framework.UI.Labels.currentPetEnchant:SetText("Current Enchant: None")
                        end
                    end
                end
            end)
        else
            Framework.UI.Labels.currentEnchantingPet:SetText("Current Pet: None")
            Framework.UI.Labels.currentPetEnchant:SetText("Current Enchant: None")
        end
        
        -- Queue info (we'll track this in the Start() function)
        local queueSize = Framework.State.enchantQueueSize or 0
        local completed = Framework.State.enchantQueueCompleted or 0
        local totalSpins = Framework.State.enchantTotalSpins or 0
        
        Framework.UI.Labels.queueSize:SetText("Pets in Queue: " .. queueSize)
        Framework.UI.Labels.queueCompleted:SetText("Completed: " .. completed)
        Framework.UI.Labels.totalSpins:SetText("Total Spins: " .. totalSpins)
        
        -- Next 3 in queue
        if Framework.State.enchantQueue and #Framework.State.enchantQueue > 0 then
            for i = 1, 3 do
                local pet = Framework.State.enchantQueue[i]
                if pet and not pet.completed then
                    Framework.UI.Labels["queuePet" .. i]:SetText(i .. ". " .. pet.name)
                else
                    Framework.UI.Labels["queuePet" .. i]:SetText(i .. ". None")
                end
            end
        else
            Framework.UI.Labels.queuePet1:SetText("1. None")
            Framework.UI.Labels.queuePet2:SetText("2. None")
            Framework.UI.Labels.queuePet3:SetText("3. None")
        end
    end)
    
     -- ========== CRYSTAL MANAGEMENT BOX ==========
    CrystalBox:AddInput("MinCrystalsThreshold", {
        Default = "10",
        Numeric = false,
        Finished = true,
        Text = "Min Crystals Threshold",
        Tooltip = "Start farming if crystals drop below this amount (supports shorthand: 10k, 1.5M, etc.)",
        Placeholder = "e.g., 10 or 7k or 1.5M",
        Callback = function(Value)
            -- Parse shorthand notation (7k, 1.5M, 2B, etc.)
            local threshold = 10  -- Default value
            
            if Value and Value ~= "" then
                -- Remove commas and spaces
                Value = string.gsub(Value, ",", "")
                Value = string.gsub(Value, "%s+", "")
                
                -- Extract number and suffix
                local numPart = tonumber(string.match(Value, "([%d%.]+)"))
                
                if numPart then
                    local suffix = string.match(Value, "([KMBTQSNODUkmbqsnodu]+)$")
                    
                    if suffix then
                        suffix = string.upper(suffix)
                        local multipliers = {
                            K = 1e3,
                            M = 1e6,
                            B = 1e9,
                            T = 1e12,
                            QD = 1e15,
                            QN = 1e18,
                            SX = 1e21,
                            SP = 1e24,
                            O = 1e27,
                            N = 1e30,
                            DC = 1e33,
                            UD = 1e36,
                            DD = 1e39,
                            TD = 1e42
                        }
                        
                        threshold = numPart * (multipliers[suffix] or 1)
                    else
                        threshold = numPart
                    end
                end
            end
            
            Framework.State.minCrystalsThreshold = math.max(1, threshold)
            
            if threshold >= 1000 then
                Framework.UI.Library:Notify("Min crystals threshold set to " .. Framework:GetModule("Format"):FormatNumber(threshold), 2)
            else
                Framework.UI.Library:Notify("Min crystals threshold set to " .. threshold, 2)
            end
        end
    })
    
    CrystalBox:AddDropdown("CrystalFarmEgg", {
        Values = (function()
            local eggs = {"Auto-Select Best"}
            for _, egg in ipairs(Framework.Data.eggList) do
                table.insert(eggs, egg)
            end
            return eggs
        end)(),
        Default = 1,
        Multi = false,
        Text = "Crystal Farm Egg",
        Tooltip = "Which egg to hatch for crystals (mythical pets drop crystals)",
        Callback = function(Value)
            if Value == "Auto-Select Best" then
                Framework.State.crystalFarmEgg = nil
                Framework.UI.Library:Notify("Will auto-select best mythical egg", 2)
            else
                Framework.State.crystalFarmEgg = string.match(Value, "^(.-)%s*%(") or Value
                Framework.UI.Library:Notify("Crystal farm egg: " .. Framework.State.crystalFarmEgg, 2)
            end
        end
    })
    
    CrystalBox:AddDropdown("CrystalFarmAmount", {
        Values = {"1", "3", "8 (Gamepass)"},
        Default = 2,
        Multi = false,
        Text = "Farm Hatch Amount",
        Tooltip = "How many eggs to hatch at once when farming crystals",
        Callback = function(Value)
            if Value == "1" then
                Framework.State.crystalFarmAmount = 1
            elseif Value == "3" then
                Framework.State.crystalFarmAmount = 3
            elseif Value == "8 (Gamepass)" then
                Framework.State.crystalFarmAmount = 8
            end
            Framework.UI.Library:Notify("Crystal farm hatch amount: " .. Framework.State.crystalFarmAmount, 2)
        end
    })
    
    CrystalBox:AddToggle("AutoFarmCrystals", {
        Text = "Auto Farm Crystals",
        Default = false,
        Tooltip = "Automatically farm enchant crystals by hatching mythical eggs when low",
        Callback = function(Value)
            Framework.State.autoFarmCrystals = Value
            if Value then
                Framework.UI.Library:Notify("Auto Crystal Farming enabled - will activate when crystals are low", 3)
                
                -- Start a monitoring loop with proper cleanup
                local monitoringTask = task.spawn(function()
                    while Framework.State.autoFarmCrystals and getgenv().TapSimLoaded do
                        local crystals = Framework:GetModule("AutoEnchant"):GetEnchantCrystals()
                        
                        -- Only farm if we're below threshold AND not already farming
                        if crystals < Framework.State.minCrystalsThreshold and not Framework.State.isCurrentlyFarmingCrystals then
                            Framework:GetModule("AutoEnchant"):AttemptFarmCrystals()
                        end
                        
                        task.wait(5) -- Check every 5 seconds
                    end
                end)
                
                -- Store task reference for cleanup
                Framework:AddConnection("CrystalFarmMonitor", {
                    Disconnect = function()
                        Framework.State.autoFarmCrystals = false
                        if monitoringTask then
                            task.cancel(monitoringTask)
                        end
                    end
                })
            else
                Framework.UI.Library:Notify("Auto Crystal Farming disabled", 2)
                -- Stop any active farming
                if Framework.State.isCurrentlyFarmingCrystals then
                    Framework.State.isCurrentlyFarmingCrystals = false
                end
                Framework:RemoveConnection("CrystalFarmMonitor")
            end
        end
    })

    CrystalBox:AddDivider()
    CrystalBox:AddLabel("Crystal Farming Status")
    
    Framework.UI.Labels.crystalFarmStatus = CrystalBox:AddLabel("Status: Idle")
    Framework.UI.Labels.currentCrystals = CrystalBox:AddLabel("Current Crystals: 0")
    Framework.UI.Labels.crystalThreshold = CrystalBox:AddLabel("Threshold: 10")
    
    UIUpdateManager:Register("crystalFarmStatus", function()
        local crystals = Framework:GetModule("AutoEnchant"):GetEnchantCrystals()
        Framework.UI.Labels.currentCrystals:SetText("Current Crystals: " .. Framework:GetModule("Format"):FormatNumber(crystals))
        Framework.UI.Labels.crystalThreshold:SetText("Threshold: " .. Framework:GetModule("Format"):FormatNumber(Framework.State.minCrystalsThreshold))
        
        if Framework.State.isCurrentlyFarmingCrystals then
            Framework.UI.Labels.crystalFarmStatus:SetText("Status: Farming (" .. crystals .. "/" .. Framework.State.minCrystalsThreshold .. ")")
        elseif Framework.State.autoFarmCrystals then
            if crystals >= Framework.State.minCrystalsThreshold then
                Framework.UI.Labels.crystalFarmStatus:SetText("Status: Ready (Above threshold)")
            else
                Framework.UI.Labels.crystalFarmStatus:SetText("Status: Monitoring")
            end
        else
            Framework.UI.Labels.crystalFarmStatus:SetText("Status: Disabled")
        end
    end)

    -- New Pets Tab
PetManagementBox:AddLabel("Pet Management Features")
PetManagementBox:AddDivider()
PetManagementBox:AddLabel("Coming Soon:")
PetManagementBox:AddLabel("‚Ä¢ Smart Equip Best")
PetManagementBox:AddLabel("‚Ä¢ Smart Level-up")
PetManagementBox:AddLabel("‚Ä¢ Delete by Rarity")
PetManagementBox:AddLabel("‚Ä¢ Pet Sorting Options")

PetInfoBox:AddLabel("Pet Statistics")
PetInfoBox:AddDivider()
Framework.UI.Labels.totalPets = PetInfoBox:AddLabel("Total Pets: 0")
Framework.UI.Labels.normalPets = PetInfoBox:AddLabel("Normal: 0")
Framework.UI.Labels.goldenPets = PetInfoBox:AddLabel("Golden: 0")
Framework.UI.Labels.rainbowPets = PetInfoBox:AddLabel("Rainbow: 0")
PetInfoBox:AddDivider()
Framework.UI.Labels.equippedPets = PetInfoBox:AddLabel("Equipped: 0")
Framework.UI.Labels.bestPetPower = PetInfoBox:AddLabel("Best Pet: Unknown")

-- Update pet statistics
UIUpdateManager:Register("petStats", function()
    local totalNormal = 0
    local totalGolden = 0
    local totalRainbow = 0
    local equippedCount = 0
    local bestPet = {name = "None", multiplier = 0, tier = "Normal"}
    
    -- Helper function to get multiplier from UI element
    local function getMultiplierFromFrame(petFrame)
        local success, multiplier = pcall(function()
            local multiLabel = petFrame:FindFirstChild("Main")
            if not multiLabel then return 0 end
            
            multiLabel = multiLabel:FindFirstChild("Multi")
            if not multiLabel then return 0 end
            
            local text = multiLabel.Text
            if not text then return 0 end
            
            -- Parse multiplier text (e.g., "1.5Kx" or "250x")
            local numPart = tonumber(string.match(text, "([%d%.]+)"))
            if not numPart then return 0 end
            
            local suffix = string.match(text, "([KMBTQSNODUkmbqsnodu]+)")
            if suffix then
                suffix = string.upper(suffix)
                local multipliers = {
                    K = 1e3, M = 1e6, B = 1e9, T = 1e12,
                    QD = 1e15, QN = 1e18, SX = 1e21, SP = 1e24,
                    O = 1e27, N = 1e30, DC = 1e33, UD = 1e36,
                    DD = 1e39, TD = 1e42
                }
                return numPart * (multipliers[suffix] or 1)
            else
                return numPart
            end
        end)
        
        return success and multiplier or 0
    end
    
    -- Count pets by tier from replication data
    pcall(function()
        if Framework.Data.replicationData and Framework.Data.replicationData.Data and Framework.Data.replicationData.Data.Pets then
            for petId, petData in pairs(Framework.Data.replicationData.Data.Pets) do
                if typeof(petData) == "table" then
                    -- Count by tier
                    if petData.Tier == "Normal" then
                        totalNormal = totalNormal + 1
                    elseif petData.Tier == "Golden" then
                        totalGolden = totalGolden + 1
                    elseif petData.Tier == "Rainbow" then
                        totalRainbow = totalRainbow + 1
                    end
                    
                    -- Check if equipped
                    if petData.Equipped then
                        equippedCount = equippedCount + 1
                    end
                end
            end
        end
    end)
    
    -- Get actual multipliers and find best pet from UI (both equipped and unequipped)
    pcall(function()
        -- Check equipped pets
        local equipped = p.PlayerGui.Tabs.Inventory.Menu.Categories.Pets.Inner.List.Equipped.List
        if equipped then
            for _, child in pairs(equipped:GetChildren()) do
                if child:IsA("Frame") and child.Name ~= "UIListLayout" and child.Name ~= "UIAspectRatioConstraint" and child.Name ~= "UICorner" and child.Name ~= "Template" and child.Name ~= "Pet" then
                    local multiplier = getMultiplierFromFrame(child)
                    local petName = child.Name
                    local tier = Framework:GetModule("GameHelper"):GetPetTierFromFrame(child)
                    
                    if multiplier > bestPet.multiplier then
                        bestPet.name = petName
                        bestPet.multiplier = multiplier
                        bestPet.tier = tier
                    end
                end
            end
        end
        
        -- Check unequipped pets (container)
        local container = p.PlayerGui.Tabs.Inventory.Menu.Categories.Pets.Inner.List.Container
        if container then
            for _, child in pairs(container:GetChildren()) do
                if child:IsA("Frame") and child.Name ~= "UIListLayout" and child.Name ~= "UIAspectRatioConstraint" and child.Name ~= "UICorner" and child.Name ~= "Template" then
                    local multiplier = getMultiplierFromFrame(child)
                    local petName = child.Name
                    local tier = Framework:GetModule("GameHelper"):GetPetTierFromFrame(child)
                    
                    if multiplier > bestPet.multiplier then
                        bestPet.name = petName
                        bestPet.multiplier = multiplier
                        bestPet.tier = tier
                    end
                end
            end
        end
    end)
    
    local totalPets = totalNormal + totalGolden + totalRainbow
    
    Framework.UI.Labels.totalPets:SetText("Total Pets: " .. totalPets)
    Framework.UI.Labels.normalPets:SetText("Normal: " .. totalNormal)
    Framework.UI.Labels.goldenPets:SetText("Golden: " .. totalGolden)
    Framework.UI.Labels.rainbowPets:SetText("Rainbow: " .. totalRainbow)
    Framework.UI.Labels.equippedPets:SetText("Equipped: " .. equippedCount)
    
    if bestPet.multiplier > 0 then
        local tierDisplay = bestPet.tier ~= "Normal" and " [" .. bestPet.tier .. "]" or ""
        Framework.UI.Labels.bestPetPower:SetText("Best Pet: " .. bestPet.name .. tierDisplay .. " (" .. Framework:GetModule("Format"):FormatNumber(bestPet.multiplier) .. "x)")
    else
        Framework.UI.Labels.bestPetPower:SetText("Best Pet: None")
    end
end)

    -- Teleport Box
    local teleportList = {"Spawn (1x Boost)"}
    
    -- Add all portal zones to the list
    for _, portal in ipairs(Framework.Data.portalsList) do
        table.insert(teleportList, portal)
    end
    
    if #teleportList > 0 then
        TeleportBox:AddDropdown("TeleportZone", {
            Values = teleportList,
            Default = 1,
            Multi = false,
            Text = "Select Zone",
            Tooltip = "Choose an unlocked zone to teleport to"
        })
        
        TeleportBox:AddButton({
            Text = "Teleport to Selected Zone",
            Func = function()
                local selectedZone = Framework.UI.Options.TeleportZone.Value
                if not selectedZone or selectedZone == "" then
                    Framework.UI.Library:Notify("Error: No zone selected!", 3)
                    return
                end
                
                -- Check if it's the spawn location
                if selectedZone == "Spawn (1x Boost)" then
                    local character = p.Character
                    if not character then
                        Framework.UI.Library:Notify("Error: Character not found!", 3)
                        return
                    end
                    
                    local hrp = character:FindFirstChild("HumanoidRootPart")
                    if not hrp then
                        Framework.UI.Library:Notify("Error: HumanoidRootPart not found!", 3)
                        return
                    end
                    
                    local success = pcall(function()
                        hrp.CFrame = CFrame.new(-151.890381, 209.534592, 247.455856, -1, 0, 0, 0, 1, 0, 0, 0, -1)
                    end)
                    
                    if success then
                        Framework.UI.Library:Notify("Teleported to Spawn", 2)
                    else
                        Framework.UI.Library:Notify("Failed to teleport to Spawn", 3)
                    end
                    return
                end
                
                -- Otherwise, use the portal teleport remote
                local zoneName = string.match(selectedZone, "^(.-)%s*%(") or selectedZone
                
                local success = pcall(function()
                    Framework.Remotes.teleport:InvokeServer(zoneName)
                end)
                
                if success then
                    Framework.UI.Library:Notify("Teleported to " .. selectedZone, 2)
                else
                    Framework.UI.Library:Notify("Failed to teleport (zone may be locked)", 3)
                end
            end,
            Tooltip = "Teleport to the selected zone/island"
        })
    else
        TeleportBox:AddLabel("No portals/zones detected")
    end
    
    TeleportBox:AddDivider()
    
    TeleportBox:AddButton({
        Text = "Set Current Position",
        Func = function()
            if Framework:GetModule("Teleport"):SavePosition() then
                Framework.UI.Library:Notify("‚úì Position saved!", 2)
            end
        end,
        Tooltip = "Save your current position to return to later"
    })
    
    TeleportBox:AddButton({
        Text = "Teleport to Saved Position",
        Func = function()
            Framework:GetModule("Teleport"):LoadPosition()
        end,
        Tooltip = "Teleport back to your saved position"
    })
    
    TeleportBox:AddButton({
        Text = "Clear Saved Position",
        Func = function()
            Framework:GetModule("Teleport"):ClearPosition()
        end,
        Tooltip = "Remove the saved position"
    })
    
    TeleportBox:AddDivider()
    
    TeleportBox:AddDropdown("PortalUnlockMode", {
    Values = {"Tween", "Purchase"},
    Default = 1,
    Multi = false,
    Text = "Unlock Mode",
    Tooltip = "Choose how to unlock portals: Tween (fast movement) or Purchase (instant with sufficient clicks)",
    Callback = function(Value)
        if Value == "Tween" then
            Framework:GetModule("Portal").unlockMode = "Tween"
            Framework.UI.Library:Notify("Portal unlock mode: Tween (movement-based)", 2)
        elseif Value == "Purchase" then
            Framework:GetModule("Portal").unlockMode = "Purchase"
            Framework.UI.Library:Notify("Portal unlock mode: Purchase (click-based)", 2)
        end
    end
})
    
    TeleportBox:AddToggle("AutoUnlockPortals", {
        Text = "Auto Unlock Portals",
        Default = false,
        Tooltip = "Automatically unlocks locked portals/islands (checks every 3 seconds)",
        Callback = function(Value)
            if Value then
                Framework:GetModule("Portal"):Enable()
            else
                Framework:GetModule("Portal"):Disable()
            end
        end
    })

    UISettings:AddToggle("ShowNotifications", {
        Text = "Show Notifications",
        Default = true,
        Tooltip = "Master toggle for all notifications"
    })
    
    UISettings:AddDivider()
    UISettings:AddLabel("Notification Filters")
    
    UISettings:AddToggle("NotifyHatch", {
        Text = "Hatch/Inventory Notifications",
        Default = true,
        Tooltip = "Show notifications related to hatching and inventory",
        Callback = function(Value)
            Framework.State.notificationFilters.showHatch = Value
        end
    })
    
    UISettings:AddToggle("NotifyCraft", {
        Text = "Crafting Notifications",
        Default = true,
        Tooltip = "Show notifications for golden/rainbow crafting",
        Callback = function(Value)
            Framework.State.notificationFilters.showCraft = Value
        end
    })
    
    UISettings:AddToggle("NotifyRebirth", {
        Text = "Rebirth Notifications",
        Default = true,
        Tooltip = "Show rebirth-related notifications",
        Callback = function(Value)
            Framework.State.notificationFilters.showRebirth = Value
        end
    })
    
    UISettings:AddToggle("NotifyUpgrade", {
        Text = "Upgrade Notifications",
        Default = true,
        Tooltip = "Show upgrade purchase notifications",
        Callback = function(Value)
            Framework.State.notificationFilters.showUpgrade = Value
        end
    })
    
    UISettings:AddToggle("NotifyPortal", {
        Text = "Portal Notifications",
        Default = true,
        Tooltip = "Show portal unlock notifications",
        Callback = function(Value)
            Framework.State.notificationFilters.showPortal = Value
        end
    })
    
    UISettings:AddToggle("NotifyGeneral", {
        Text = "General Notifications",
        Default = true,
        Tooltip = "Show general/miscellaneous notifications",
        Callback = function(Value)
            Framework.State.notificationFilters.showGeneral = Value
        end
    })
    
    UISettings:AddDivider()
    
    UISettings:AddButton({
    Text = "Unload Script",
    Func = function()
        print("üõë Unloading script...")
        
        -- Stop all feature modules
        pcall(function() Framework:GetModule("AutoTap"):Stop() end)
        pcall(function() Framework:GetModule("AutoRebirth"):Stop() end)
        pcall(function() Framework:GetModule("AutoHatch"):Stop() end)
        pcall(function() Framework:GetModule("AutoBuyUpgrades"):Stop() end)
        pcall(function() Framework:GetModule("AutoCraftGolden"):Stop() end)
        pcall(function() Framework:GetModule("AutoCraftRainbow"):Stop() end)
        pcall(function() Framework:GetModule("AutoClaimRainbow"):Stop() end)
        pcall(function() Framework:GetModule("AutoEnchant"):Stop() end)
        pcall(function() Framework:GetModule("Portal"):Disable() end)
        
        Framework.UI.Library:Notify("Stopping all features...", 2)
        task.wait(0.5)
        
        -- Full cleanup
        Framework:Cleanup()
        
        -- Clear globals
        getgenv().TapSimLoaded = nil
        getgenv().TapSimCleanupOld = nil
        
        -- Unload UI
        Framework.UI.Library:Unload()
        
        print("‚úì Script fully unloaded")
    end,
    DoubleClick = true,
    Tooltip = "Double-click to unload and free memory"
})
    
    MenuSettings:AddLabel("Tap Simulator v2.0.0")
    MenuSettings:AddDivider()
    MenuSettings:AddLabel("Optimized & Modular")
    MenuSettings:AddLabel("Toggle: RightControl")
    
    -- Theme & Save Manager
    ThemeManager:SetLibrary(Framework.UI.Library)
    ThemeManager:SetFolder("TapSimulator")
    ThemeManager:ApplyToTab(SettingsTab)
    
    SaveManager:SetLibrary(Framework.UI.Library)
    SaveManager:SetFolder("TapSimulator/configs")
    SaveManager:BuildConfigSection(SettingsTab)
    SaveManager:LoadAutoloadConfig()
end

-- Initialize everything
Framework:GetModule("DataLoader")
-- Cleanup when player leaves game
local Players = game:GetService("Players")
Players.LocalPlayer.OnTeleport:Connect(function()
    if getgenv().TapSimLoaded then
        print("üö™ Player teleporting - cleaning up...")
        Framework:Cleanup()
        getgenv().TapSimLoaded = nil
    end
end)

-- Also cleanup if the script is reloaded
if getgenv().TapSimCleanupOld then
    pcall(getgenv().TapSimCleanupOld)
end
getgenv().TapSimCleanupOld = function()
    if getgenv().TapSimLoaded then
        Framework:Cleanup()
    end
end

BuildUI()
Framework:GetModule("UIUpdate"):Start()

Framework.UI.Library:Notify("‚úì Tap Simulator v2.0.0 loaded successfully!", 5)
print("‚úì All systems operational")
print("‚úì Framework loaded with " .. #Framework.Data.eggList .. " eggs, " .. #Framework.Data.rebirthList .. " rebirth tiers, " .. #Framework.Data.portalsList .. " portals")
